<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>姚俊的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-02-25T11:41:48.542Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>胖胖</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用Sass混合指令@mixin和媒体查询实现页面响应式布局</title>
    <link href="http://yoursite.com/post/2804030403.html"/>
    <id>http://yoursite.com/post/2804030403.html</id>
    <published>2019-02-25T10:46:54.000Z</published>
    <updated>2019-02-25T11:41:48.542Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$breakpoints: (&apos;sm&apos;:&apos;only screen and (max-device-width: 1024px)&apos;,&apos;md&apos;: &apos;only screen and (min-device-width: 1025px) and (max-device-width: 1680px)&apos;, &apos;lg&apos;: &apos;only screen and (min-device-width: 1681px)&apos;);</span><br><span class="line">@mixin respond-to($screensize)&#123;</span><br><span class="line"> $value: map-get($breakpoints,$screensize);</span><br><span class="line">    @if not $value&#123;</span><br><span class="line">     @error &apos;no value found&apos;</span><br><span class="line">    &#125;</span><br><span class="line">    @media #&#123;$value&#125;&#123;</span><br><span class="line">     @content;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@mixin respond-font-size($sizes)&#123;</span><br><span class="line">@each $key,$value in $sizes&#123;</span><br><span class="line">     @include respond-to($key)&#123;</span><br><span class="line">        font-size: #&#123;$value&#125;px;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>D3.js框架使用总结</title>
    <link href="http://yoursite.com/post/2361688348.html"/>
    <id>http://yoursite.com/post/2361688348.html</id>
    <published>2019-02-19T02:51:22.000Z</published>
    <updated>2019-02-26T12:34:59.009Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前玩过Highcharts和Echarts可视化图形框架，绘制几种固定种类的、十分大众化的图表可谓是非常的方便，但是由于它们的封装程度太高了，对于如果希望开发脑海中任意想象到的图表来说就比较麻烦了；然而使用D3.js框架就比较容易了，D3.js 是基于数据操作文档的 JavaScript 库，通过 HTML、SVG 和 CSS 赋予数据以生命。D3 集强力的可视化组件与数据驱动型的 DOM 操作手法于一身，能最大限度地引出现代浏览器的性能，而不必束缚于特定的框架。D3 有一个很独特的功能：可以通过D3选择权器来获取页面中的DOM元素和添加删除DOM元素等，并能将数据绑定到 DOM 上，也就是绑定到文档上，绑定之后，当需要依靠这个数据才操作元素的时候，会很方便。 D3 提供了众多的 SVG 图形的生成器，它们都是只支持 SVG 的。因此，建议使用 SVG 画布。在 SVG 画布的预定义元素里，有六种基本图形：</p><ul><li>矩形</li><li>圆形</li><li>椭圆</li><li>线段</li><li>折线</li><li>多边形</li></ul><p>另外，还有一种比较特殊，也是功能最强的元素：</p><ul><li>路径</li></ul><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>布局是 D3 中一个十分重要的概念。D3 与其它很多可视化工具不同，相对来说较底层，对初学者来说不太方便，但是一旦掌握了，就比其他工具更加得心应手。简单的来说布局的作用是：将不适合用于绘图的数据转换成了适合用于绘图的数据。D3 总共提供了 12 个布局分别为：</p><ol><li>饼状图（Pie）</li><li>力导向图（Force）</li><li>弦图（Chord）</li><li>树状图（Tree）</li><li>集群图（Cluster）</li><li>捆图（Bundle）</li><li>打包图（Pack）</li><li>直方图（Histogram）</li><li>分区图（Partition）</li><li>堆栈图（Stack）</li><li>矩阵树图（Treemap）</li><li>层级图（Hierarchy）</li></ol><p>12 个布局中，层级图（Hierarchy）不能直接使用。集群图、打包图、分区图、树状图、矩阵树图是由层级图扩展来的。如此一来，能够使用的布局是 11 个（有 5 个是由层级图扩展而来）。这些布局的作用都是将某种数据转换成另一种数据，而转换后的数据是利于可视化的。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div class="note default"><p><a href="http://d3.decembercafe.org/index.html" target="_blank" rel="noopener">Learning D3.js</a><br><a href="https://www.jianshu.com/p/1c22523624f6" target="_blank" rel="noopener">D3.js初体验</a></p></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;之前玩过Highcharts和Echarts可视化图形框架，绘制几种固定种类的、十分大众化的图表可谓是非常的方便，但是由于它们的封装程度太高
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>webpack4教程</title>
    <link href="http://yoursite.com/post/1413616213.html"/>
    <id>http://yoursite.com/post/1413616213.html</id>
    <published>2019-02-19T02:01:53.000Z</published>
    <updated>2019-02-26T12:33:54.431Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。webpack是前端目前最主流的javascript打包工具，在它的帮助下，开发者可以轻松地实现加密代码、多平台兼容。而最重要的是，它为前端工程化提供了最好支持。vue、react等大型项目的脚手架都是利用 webpack 搭建。</p><h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><ol><li><a href="https://godbmw.com/passages/2018-07-30-webpack-pack-js/" target="_blank" rel="noopener"><font color="blue">编写<strong>webpack.config.js</strong>，打包基本的js文件</font></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&quot;path&quot;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: &quot;./app.js&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    publicPath: __dirname + &quot;/dist/&quot;, // js引用路径或者CDN地址,换句话说就是js文件内部引用其他文件的路径。</span><br><span class="line">    path: path.resolve(__dirname, &quot;dist&quot;), // 打包文件的输出目录</span><br><span class="line">    filename: &quot;bundle.js&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><a href="https://godbmw.com/passages/2018-07-31-webpack-compile-es6/" target="_blank" rel="noopener"><font color="blue">webpack可以编译ES6，通过<strong>babel-loader</strong>把ES6转化成浏览器支持的js文件，通过<strong>babel-polyfill</strong>可以添加浏览器不支持的ES6的方法和函数，比如<code>new Set()</code></font></a> ，启动babel配置如下：<ul><li><strong>.babelrc文件</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    [</span><br><span class="line">      &quot;env&quot;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;targets&quot;: &#123;</span><br><span class="line">          &quot;browsers&quot;: [&quot;last 2 versions&quot;]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ],</span><br><span class="line">  &quot;plugins&quot;: [&quot;transform-runtime&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>webpack.config.js配置<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: &quot;./app.js&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &quot;bundle.js&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.js$/,</span><br><span class="line">        exclude: /(node_modules)/,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: &quot;babel-loader&quot; </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>使用babel-polyfill，它需要在我们项目的入口文件中被引入，或者在webpack.config.js中配置。这里我们采用第一种方法编写app.js:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> import &quot;babel-polyfill&quot;;</span><br><span class="line">let func = () =&gt; &#123;&#125;;</span><br><span class="line">const NUM = 45;</span><br><span class="line">let arr = [1, 2, 4];</span><br><span class="line">let arrB = arr.map(item =&gt; item * 2);</span><br><span class="line"></span><br><span class="line">console.log(arrB.includes(8));</span><br><span class="line">console.log(&quot;new Set(arrB) is &quot;, new Set(arrB));</span><br></pre></td></tr></table></figure></li></ul></li><li><a href="https://godbmw.com/passages/2018-08-06-webpack-mutiple-pages/" target="_blank" rel="noopener"><font color="blue">可以通过<strong>optimization.splitChunks</strong>来提取公共代码。webpack3.0以前提取使用的是CommonsChunkPlugin插件。</font></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  // 多页面应用</span><br><span class="line">  entry: &#123;</span><br><span class="line">    pageA: &quot;./src/pageA.js&quot;,</span><br><span class="line">    pageB: &quot;./src/pageB.js&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, &quot;dist&quot;),</span><br><span class="line">    filename: &quot;[name].bundle.js&quot;,</span><br><span class="line">    chunkFilename: &quot;[name].chunk.js&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        // 注意: priority属性</span><br><span class="line">        // 其次: 打包业务中公共代码</span><br><span class="line">        common: &#123;</span><br><span class="line">          name: &quot;common&quot;,</span><br><span class="line">          chunks: &quot;all&quot;,</span><br><span class="line">          minSize: 1,</span><br><span class="line">          priority: 0</span><br><span class="line">        &#125;,</span><br><span class="line">        // 首先: 打包node_modules中的文件</span><br><span class="line">        vendor: &#123;</span><br><span class="line">          name: &quot;vendor&quot;,</span><br><span class="line">          test: /[\\/]node_modules[\\/]/,</span><br><span class="line">          chunks: &quot;all&quot;,</span><br><span class="line">          priority: 10</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><a href="https://godbmw.com/passages/2018-08-08-webpack-spa-split-lazy/" target="_blank" rel="noopener"><font color="blue">通过<strong>import</strong>或者<strong>require.ensure()</strong>实现代码的分割了懒加载</font></a><ul><li>import(): 引入并且自动执行相关 js 代码</li><li>require.ensure(): 引入但需要手动执行相关 js 代码</li></ul></li><li><a href="https://godbmw.com/passages/2018-08-17-webpack-css/" target="_blank" rel="noopener"><font color="blue">通过css-loader、file-loader和style-loader来处理</font></a><ul><li>css-loader: 加载.css文件</li><li>style-loade: 使用<code>&lt;style&gt;</code>将css-loader内部样式注入到我们的HTML页面，我们可以通过style-loader提供的<code>use()</code>和<code>unuse()</code>两种方法来动态加载和卸载css样式；通过style-loader增加<code>options.tranform</code>属性在加载css样式前，更改css.</li><li>url-loader: url-loader可以将图片转为base64字符串，能更快的加载图片,针对小图片</li><li>file-loader: 一旦图片过大，就需要使用file-loader的加载本地图片，故url-loader可以设置图片超过多少字节时，使用file-loader加载图片。</li></ul></li><li><a href="https://godbmw.com/passages/2018-08-18-webpack-scss/" target="_blank" rel="noopener"><font color="blue">通过node-sass、sass-loader加载器来处理scss</font></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.scss$/,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &quot;style-loader&quot; // 将 JS 字符串生成为 style 节点</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &quot;css-loader&quot; // 将 CSS 转化成 CommonJS 模块</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &quot;sass-loader&quot; // 将 Sass 编译成 CSS</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><a href="https://godbmw.com/passages/2018-08-28-webpack-scss-lazy/" target="_blank" rel="noopener"><font color="blue">使用extract-text-webpack-plugin插件实现实现 SCSS 懒加载</font></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">   rules: [</span><br><span class="line">     &#123;</span><br><span class="line">       test: /\.scss$/,</span><br><span class="line">       use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">         // 注意 1</span><br><span class="line">         fallback: &#123;</span><br><span class="line">           loader: &quot;style-loader&quot;</span><br><span class="line">         &#125;,</span><br><span class="line">         use: [</span><br><span class="line">           &#123;</span><br><span class="line">             loader: &quot;css-loader&quot;,</span><br><span class="line">             options: &#123;</span><br><span class="line">               minimize: true</span><br><span class="line">             &#125;</span><br><span class="line">           &#125;,</span><br><span class="line">           &#123;</span><br><span class="line">             loader: &quot;sass-loader&quot;</span><br><span class="line">           &#125;</span><br><span class="line">         ]</span><br><span class="line">       &#125;)</span><br><span class="line">     &#125;</span><br><span class="line">   ]</span><br><span class="line"> &#125;,</span><br><span class="line"> plugins: [</span><br><span class="line">   new ExtractTextPlugin(&#123;</span><br><span class="line">     filename: &quot;[name].min.css&quot;,</span><br><span class="line">     allChunks: false // 注意 2</span><br><span class="line">   &#125;)</span><br><span class="line"> ]</span><br></pre></td></tr></table></figure>common.scss为懒加载的文件，此时需要在项目app.js入口中引入<code>style-loader/lib/addStyles</code>和<code>css-loader/lib/css-base</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> /**webpack4: 针对scss的懒加载, 需要以下代码 */</span><br><span class="line">import &quot;style-loader/lib/addStyles&quot;;</span><br><span class="line">import &quot;css-loader/lib/css-base&quot;;</span><br><span class="line">/**************************************** */</span><br><span class="line"></span><br><span class="line">import &quot;./scss/base.scss&quot;;</span><br><span class="line"></span><br><span class="line">var loaded = false;</span><br><span class="line">window.addEventListener(&quot;click&quot;, function() &#123;</span><br><span class="line">  if (!loaded) &#123;</span><br><span class="line">    import(/* webpackChunkName: &apos;style&apos;*/ &quot;./scss/common.scss&quot;).then(_ =&gt; &#123;</span><br><span class="line">      console.log(&quot;Change bg-color of html&quot;);</span><br><span class="line">      loaded = true;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br></pre></td></tr></table></figure>根据我们在app.js中的webpackChunkName的配置，可以猜测，打包结果中有：style.chunk.js 文件</li><li><a href="https://godbmw.com/passages/2018-09-01-js-tree-shaking/" target="_blank" rel="noopener"><font color="blue">使用JS Tree Shaking 在项目中没有使用的代码会在打包时候丢掉。<strong>注意：JS 的 Tree Shaking 依赖的是 ES2015 的模块系统（比如：import和export），因此针对第三方JS库，需要注意他是否符合ES模板系统规范。</strong>使用时不再需要UglifyjsWebpackPlugin插件， 取而代之的是，更加方便的配置方法。只需要配置mode为”production”，即可显式激活 UglifyjsWebpackPlugin 插件。</font></a></li><li><a href="https://godbmw.com/passages/2018-09-02-css-tree-shaking/" target="_blank" rel="noopener"><font color="blue">通过使用PruifyCSS和glob-all第三方库来实现Css Tree Shaking</font></a></li><li><a href="https://godbmw.com/passages/2018-09-11-webpack-image/" target="_blank" rel="noopener"><font color="blue">处理图片和进行base64编码时候使用<strong>url-loader</strong>，压缩图片可以使用<strong>img-loader</strong>，<strong>postcss-loader</strong>和<strong>postcss-sprites</strong>则用来合成雪碧图，从而减少网络请求</font></a></li><li><a href="https://godbmw.com/passages/2018-10-09-webpack-chracter-file/" target="_blank" rel="noopener"><font color="blue">借助url-loader，可以识别并且处理eot、woff等结尾的字体文件。同时，根据字体文件大小，可以灵活配置是否进行base64编码</font></a></li><li><a href="https://godbmw.com/passages/2018-10-09-webpack-js-pacakge/" target="_blank" rel="noopener"><font color="blue">针对第三种方法，如果没有webpack，则需要手动引入import或者require来加载文件；但是，webpack提供了<strong>alias</strong>的配置，配合<strong>webpack.ProvidePlugin</strong>这款插件，可以跳过手动入，直接使用！</font></a></li><li><a href="https://godbmw.com/passages/2018-10-17-automatic-html/" target="_blank" rel="noopener"><font color="blue">通过<strong>html-webpack-plugin</strong>插件来自动生成html</font></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      filename: &quot;index.html&quot;,</span><br><span class="line">      template: &quot;./index.html&quot;,</span><br><span class="line">      chunks: [&quot;app&quot;], // entry中的app入口才会被打包</span><br><span class="line">      minify: &#123;</span><br><span class="line">        // 压缩选项</span><br><span class="line">        collapseWhitespace: true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></li><li><a href="https://godbmw.com/passages/2018-10-18-webpack-clean-and-watch-mode/" target="_blank" rel="noopener"><font color="blue"><strong>CleanWebpackPlugin</strong>，在每次打包前，自动清理/dist/目录下的文件。</font></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: &quot;./app.js&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    publicPath: __dirname + &quot;/dist/&quot;, // js引用路径或者CDN地址</span><br><span class="line">    path: path.resolve(__dirname, &quot;dist&quot;), // 打包文件的输出目录</span><br><span class="line">    filename: &quot;[name]-[hash:5].bundle.js&quot;,</span><br><span class="line">    chunkFilename: &quot;[name]-[hash:5].chunk.js&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      filename: &quot;index.html&quot;,</span><br><span class="line">      template: &quot;./index.html&quot;,</span><br><span class="line">      chunks: [&quot;app&quot;]</span><br><span class="line">    &#125;),</span><br><span class="line">    new CleanWebpackPlugin([&quot;dist&quot;])</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><a href="https://godbmw.com/passages/2018-10-18-webpack-clean-and-watch-mode/" target="_blank" rel="noopener"><font color="blue">webpack-dev-server插件可以启动一个本地服务，可以进行热重载、路由重定向、挂代理等功能和sourcemap帮助开发进行代码调试</font></a></li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div class="note default"><p><a href="https://www.cnblogs.com/geyouneihan/p/9827295.html" target="_blank" rel="noopener">全网最贴心webpack系列教程和配套代码</a><br><a href="https://www.cnblogs.com/axl234/p/6500534.html" target="_blank" rel="noopener">Webpack中的sourcemap</a></p></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>短/长轮询和WebSocket的优缺点</title>
    <link href="http://yoursite.com/post/1122290469.html"/>
    <id>http://yoursite.com/post/1122290469.html</id>
    <published>2019-02-16T08:24:21.000Z</published>
    <updated>2019-02-16T08:41:27.889Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闲言"><a href="#闲言" class="headerlink" title="闲言"></a>闲言</h2><h2 id="短轮询"><a href="#短轮询" class="headerlink" title="短轮询"></a>短轮询</h2><p><strong>定义：</strong>其实就是普通的轮询。指在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP request，然后由服务器返回最新的数据给客户端的浏览器。</p><p><strong>应用场景：</strong>传统的web通信模式。后台处理数据，需要一定时间，前端想要知道后端的处理结果，就要不定时的向后端发出请求以获得最新情况。</p><p><strong>优点：</strong>前后端程序编写比较容易。</p><p><strong>缺点：</strong>请求中有大半是无用，难于维护，浪费带宽和服务器资源；响应的结果没有顺序（因为是异步请求，当发送的请求没有返回结果的时候，后面的请求又被发送。而此时如果后面的请求比前面的请 求要先返回结果，那么当前面的请求返回结果数据时已经是过时无效的数据了）。</p><p><strong>实例：</strong>适于小型应用。</p><h2 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h2><p><strong>定义：</strong>客户端向服务器发送Ajax请求，服务器接到请求后hold住连接，直到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求。</p><p><strong>优点：</strong>在无消息的情况下不会频繁的请求，耗费资源小。</p><p><strong>缺点：</strong>服务器hold连接会消耗资源，返回数据顺序无保证，难于管理维护。</p><h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p><strong>定义：</strong>Websocket是基于HTTP协议的，在和服务端建立了链接后，服务端有数据有了变化后会主动推送给前端。</p><p><strong>优点：</strong>请求响应快，不浪费资源。（传统的http请求，其并发能力都是依赖同时发起多个TCP连接访问服务器实现的(因此并发数受限于浏览器允许的并发连接数)，而websocket则允许我们在一条ws连接上同时并发多个请求，即在A请求发出后A响应还未到达，就可以继续发出B请求。由于TCP的慢启动特性（新连接速度上来是需要时间的），以及连接本身的握手损耗，都使得websocket协议的这一特性有很大的效率提升；http协议的头部太大，且每个请求携带的几百上千字节的头部大部分是重复的，websocket则因为复用长连接而没有这一问题。）</p><p><strong>缺点：</strong>主流浏览器支持的Web Socket版本不一致；服务端没有标准的API，下图是各大主流对websocket的兼容性列表。<br><img src="/post/1122290469/websocket.png"></p><p><strong>实例：</strong>实现即时通讯:如股票交易行情分析、聊天室、在线游戏等，替代轮询和长轮询</p><p><strong>解决：</strong>解决了http协议的两个问题:</p><ol><li>服务端的被动性。http协议是只有客户端询问之后才回复。解决了同步有延迟的问题</li><li>解决了服务器上消耗资源的问题</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div class="note default"><p><a href="https://blog.csdn.net/yingzizizizizizzz/article/details/83416987" target="_blank" rel="noopener">短轮询、长轮询和web socket定义及其实现</a></p></div> ]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;闲言&quot;&gt;&lt;a href=&quot;#闲言&quot; class=&quot;headerlink&quot; title=&quot;闲言&quot;&gt;&lt;/a&gt;闲言&lt;/h2&gt;&lt;h2 id=&quot;短轮询&quot;&gt;&lt;a href=&quot;#短轮询&quot; class=&quot;headerlink&quot; title=&quot;短轮询&quot;&gt;&lt;/a&gt;短轮询&lt;/h2&gt;&lt;p
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>如何进行前端网页性能优化</title>
    <link href="http://yoursite.com/post/3048684187.html"/>
    <id>http://yoursite.com/post/3048684187.html</id>
    <published>2019-01-31T15:25:00.000Z</published>
    <updated>2019-02-15T13:36:09.248Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闲言"><a href="#闲言" class="headerlink" title="闲言"></a>闲言</h2><p>好的用户体验对于任何一个Web App都是一个非常重要的方面，想要拥有一个好的用户体验，网页的性能优化是必不可少的环节；特别是针对项目比较大、并发性比较高或者页面结构和业务逻辑比较复杂的应用，性能优化在其中体现出至关重要的一部分。下面主要针对http1.1协议来讲解一下如何让一个Web App尽可能的做到性能的极致优化。由于本人知识有限，如有描述错误，请各位同学留言指正。</p><h2 id="http请求和加载的优化"><a href="#http请求和加载的优化" class="headerlink" title="http请求和加载的优化"></a>http请求和加载的优化</h2><h3 id="一-减少http请求数量"><a href="#一-减少http请求数量" class="headerlink" title="一. 减少http请求数量"></a>一. 减少http请求数量</h3><p>在http1.1中，浏览器针对同一域名下的并发请求数量是一定的，换句话说同一域名浏览器在同一时间加载的资源（css、js或者是图片等）是一定的，一般4到5个，不同的浏览器稍有差异。因此优化目标可以分为以下两个方面：</p><ol><li>提高浏览器的并发请求所需资源的数量</li><li>合并资源，浏览器的每次请求可以获取更多的有用资源<br>因此我们可以针对以上两个方面进行优化。</li></ol><h4 id="1-适当的合并js、css和图片"><a href="#1-适当的合并js、css和图片" class="headerlink" title="1. 适当的合并js、css和图片"></a>1. 适当的合并js、css和图片</h4><p>可以使用webpack等打包工具把不经常修改的文件合并在一起。这样的话不仅可以减少请求数量，也可以很好的利用了http的缓存。</p><h4 id="2-适当的使用CSS-sprite也叫作CSS精灵"><a href="#2-适当的使用CSS-sprite也叫作CSS精灵" class="headerlink" title="2. 适当的使用CSS sprite也叫作CSS精灵"></a>2. 适当的使用CSS sprite也叫作CSS精灵</h4><p>通过使用图片合成工具把需要的各种小图标合并成一张大图标，再通过css的<code>background-position</code>来定位所需要的图片</p><h4 id="3-针对小图片也可以使用Data-RUL协议，这样图片被转换成base64编码的字符串形式-嵌入到了html中，这样在加载html时候图片资源也跟着html资源一起加载进来，减少了http请求数量；但是这样做的坏处是："><a href="#3-针对小图片也可以使用Data-RUL协议，这样图片被转换成base64编码的字符串形式-嵌入到了html中，这样在加载html时候图片资源也跟着html资源一起加载进来，减少了http请求数量；但是这样做的坏处是：" class="headerlink" title="3. 针对小图片也可以使用Data RUL协议，这样图片被转换成base64编码的字符串形式,嵌入到了html中，这样在加载html时候图片资源也跟着html资源一起加载进来，减少了http请求数量；但是这样做的坏处是："></a>3. 针对小图片也可以使用<a href="http://www.webhek.com/post/data-url.html" target="_blank" rel="noopener">Data RUL协议</a>，这样图片被转换成base64编码的字符串形式,嵌入到了html中，这样在加载html时候图片资源也跟着html资源一起加载进来，减少了http请求数量；但是这样做的坏处是：</h4><ol><li>Base64编码的数据体积通常是原数据的体积4/3，也就是Data URL形式的图片会比二进制格式的图片体积大1/3。</li><li>Data URL形式的图片不会被浏览器缓存，这意味着每次访问这样页面时都被下载一次。这是一个使用效率方面的问题——尤其当这个图片被整个网站大量使用的时候。</li></ol><div class="note primary"><p>如果想使用缓存，可以将Data URL形式的图片存储在CSS样式表中，而所有浏览器都会积极的缓存CSS文件来提高页面加载效率。具体操作可以参考<a href="http://www.webhek.com/post/data-url.html" target="_blank" rel="noopener">Data URL和图片</a></p></div><h4 id="4-可以把服务器资源放在不同的域名下，因为浏览器只会限制同一域名的请求并发数量，这样分别把不同的静态资源放入到不同的域名下，从而提高请求资源的并发数量。原理可以了解http请求头host的作用。"><a href="#4-可以把服务器资源放在不同的域名下，因为浏览器只会限制同一域名的请求并发数量，这样分别把不同的静态资源放入到不同的域名下，从而提高请求资源的并发数量。原理可以了解http请求头host的作用。" class="headerlink" title="4. 可以把服务器资源放在不同的域名下，因为浏览器只会限制同一域名的请求并发数量，这样分别把不同的静态资源放入到不同的域名下，从而提高请求资源的并发数量。原理可以了解http请求头host的作用。"></a>4. 可以把服务器资源放在不同的域名下，因为浏览器只会限制同一域名的请求并发数量，这样分别把不同的静态资源放入到不同的域名下，从而提高请求资源的并发数量。原理可以了解http请求头host的作用。</h4><h4 id="5-懒加载和预加载"><a href="#5-懒加载和预加载" class="headerlink" title="5. 懒加载和预加载"></a>5. 懒加载和预加载</h4><ul><li>懒加载：图片进入可视区域之后请求资源，对于电商，页面很长的场景，减少无效的资源加载（单页应用，观看的时候才去加载）。实现方法参考：图片的src的地址被改变的时候被加载。监听滑动的事件，当图片进入可视区域的时候才去加载。</li><li>预加载：与懒加载相反，预加载静态资源使用之前提前进行请求。直接从缓存中进行加载，不需要发送请求。</li></ul><h3 id="二-避免阻塞dom渲染"><a href="#二-避免阻塞dom渲染" class="headerlink" title="二. 避免阻塞dom渲染"></a>二. 避免阻塞dom渲染</h3><ol><li>CSS的加载不会阻塞DOM树的解析，但是会阻塞DOM树的渲染</li><li>CSS的加载会阻塞后面js语句的执行</li><li>js的加载和执行会阻塞DOM树的解析</li></ol><p>针对以上情况，优化点如下：</p><ol><li>css样式表置顶</li><li>用link代替import</li><li>js脚本置顶，放到body标签后面</li><li>合理使用js的异步加载能力</li></ol><h3 id="三-http缓存优化"><a href="#三-http缓存优化" class="headerlink" title="三. http缓存优化"></a>三. http缓存优化</h3><h3 id="四-通过Media-Query按需加载"><a href="#四-通过Media-Query按需加载" class="headerlink" title="四. 通过Media Query按需加载"></a>四. 通过Media Query按需加载</h3><h3 id="五-减少传输文件的大小"><a href="#五-减少传输文件的大小" class="headerlink" title="五. 减少传输文件的大小"></a>五. 减少传输文件的大小</h3><img src="/post/3048684187/main.jpeg"><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div class="note default"><p><a href="https://www.jianshu.com/p/fe32ef31deed" target="_blank" rel="noopener">前端性能优化总结</a><br>    <a href="https://www.cnblogs.com/dreamowneryong/p/4773201.html" target="_blank" rel="noopener">base64图片解析</a><br>     <a href="https://www.jianshu.com/p/10ca32480c1e" target="_blank" rel="noopener">base64和css sprites的区别</a><br>     <a href="https://harttle.land/2016/05/18/async-javascript-loading.html" target="_blank" rel="noopener">异步加载脚本</a><br>     <a href="https://juejin.im/post/59d489156fb9a00a571d6509" target="_blank" rel="noopener">浏览器渲染过程与性能优化</a><br>     <a href="https://blog.seosiwei.com/detail/33" target="_blank" rel="noopener">如何做到网页性能的极致优化</a></p></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;闲言&quot;&gt;&lt;a href=&quot;#闲言&quot; class=&quot;headerlink&quot; title=&quot;闲言&quot;&gt;&lt;/a&gt;闲言&lt;/h2&gt;&lt;p&gt;好的用户体验对于任何一个Web App都是一个非常重要的方面，想要拥有一个好的用户体验，网页的性能优化是必不可少的环节；特别是针对项目比较大
      
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>ES6的Rest参数和对象展开运算符</title>
    <link href="http://yoursite.com/post/3368437986.html"/>
    <id>http://yoursite.com/post/3368437986.html</id>
    <published>2019-01-26T07:16:31.000Z</published>
    <updated>2019-02-26T12:13:07.778Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闲言"><a href="#闲言" class="headerlink" title="闲言"></a>闲言</h2><p>ES6是ECMAScript标准十余年来变动最大的一个版本，其中添加了许多新的语法特性，既有大家耳熟能详的Promise，也有闻所未闻的Proxy代理和Reflection反射；既有可以通过转译器（Transpiler）等方式在旧版本浏览器中实现兼容的let、const、不定参数、展开运算符等功能，亦有无论如何都无法实现向前兼容的尾调用优化。深入理解ES6的特性对于所有JavaScript开发者而言至关重要，在可预见的未来，ES6中引入的语言特性会成为JavaScript应用程序的主流特性。因此本文探讨ES6中的两个重要且常用的特性，它们是Rest和对象展开运算符。由于本人知识有限，如有描述错误请留言指正。</p><h2 id="Rest参数"><a href="#Rest参数" class="headerlink" title="Rest参数"></a>Rest参数</h2><p>Rest参数接受函数的多余参数，组成一个数组，放在形参的最后；形式为<code>...变量名</code>。<strong>特别注意Rest参数只会出现在函数的形参中，否则都是对象的扩展</strong>，具体实例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function add(a, b, ...params) &#123;</span><br><span class="line">    console.log(params); //[ 3, 4, 5 ]</span><br><span class="line">    console.log(arguments); // &#123; &apos;0&apos;: 1, &apos;1&apos;: 2, &apos;2&apos;: 3, &apos;3&apos;: 4, &apos;4&apos;: 5 &#125;</span><br><span class="line">    let arguArray = Array.prototype.slice.apply(arguments);</span><br><span class="line">    // let arguArray = Array.from(arguments);</span><br><span class="line">    console.log(arguArray); //[ 1, 2, 3, 4, 5 ]</span><br><span class="line">    console.log(Array.isArray(arguArray)); // true</span><br><span class="line">    console.log(Array.isArray(params)); // true</span><br><span class="line">    console.log(Array.isArray(arguments)) // false</span><br><span class="line">&#125;</span><br><span class="line">add(1, 2, 3, 4, 5);</span><br></pre></td></tr></table></figure><br>上面实例代码可以看出：</p><ul><li>Rest参数只包括那些没有给出名称的参数，arguments包含所有参数。</li><li>arguments对象不是真正的数组，因此没有数组的一些方法特性；而Rest 参数是数组实例，因此拥有数组所有的方法特性。其实arguments是一个类似数组的伪数组（具有length属性，并且按照索引方式存储数据，但是不具有push()、pop()等数组方法，形式可以看上面代码3行），可以通过上面代码中4行或者是5行转换成真正的数组。<br>如果把Rest参数不放在函数形参的最后会怎么样呢？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function add(a, ...params, b) &#123;&#125;</span><br><span class="line">add(1, 2, 3, 4, 5);</span><br></pre></td></tr></table></figure>运行结果报错：<div class="note danger"><p>SyntaxError: Rest parameter must be last formal parameter</p></div><div class="note primary"><p>结果表明Rest参数之后不能再有其他参数，换句话说它必须是形参的最后一个参数！！！</p></div></li></ul><h3 id="Rest扩展知识"><a href="#Rest扩展知识" class="headerlink" title="Rest扩展知识"></a>Rest扩展知识</h3><p>Rest参数可以被结构解析(通俗一点，将rest参数的数据解析后一一对应)不要忘记参数用[]括起来，因为它是数组，实例代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function add(a, b, ...[c, d, e]) &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">    console.log(b);</span><br><span class="line">    console.log(c);</span><br><span class="line">    console.log(d);</span><br><span class="line">    console.log(e);</span><br><span class="line">&#125;</span><br><span class="line">add(1, 2, 3, 4, 5);</span><br><span class="line">add(1, 2, 3);</span><br><span class="line">add(1,2,3,4,5,6);</span><br></pre></td></tr></table></figure><br>结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">undefined</span><br><span class="line">undefined</span><br></pre></td></tr></table></figure><br>结果表明，结构解析中如果参数传递不够，对应的变量为undefined。</p><h2 id="展开运算符"><a href="#展开运算符" class="headerlink" title="展开运算符"></a>展开运算符</h2><p>扩展运算符（spread）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。展开运算符的应用场景非常之多。</p><ul><li><strong>可以很方便的实现对象的合并</strong>。比如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let object1 = &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let object2 = &#123;</span><br><span class="line">    a: 2,</span><br><span class="line">    c: 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let object3 = &#123;...object1, ...object2 &#125;;</span><br><span class="line">let object4 = &#123;...object2, a: 3, d: 4 &#125;;</span><br><span class="line">console.log(&apos;object3：&apos;, object3);</span><br><span class="line">console.log(&apos;object4：&apos;, object4);</span><br></pre></td></tr></table></figure>结果如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">object3： &#123; a: 2, b: 2, c: 3 &#125;</span><br><span class="line">object4： &#123; a: 3, c: 3, d: 4 &#125;</span><br></pre></td></tr></table></figure></li><li><strong>合并数组</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr1 = [1, 2, 3];</span><br><span class="line">let arr2 = [4, 5];</span><br><span class="line">arr1.push(...arr2);</span><br><span class="line">console.log(arr1);</span><br></pre></td></tr></table></figure>结果如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ 1, 2, 3, 4, 5 ]</span><br></pre></td></tr></table></figure>如果你想要整合两个数组，并且想把某个数组放在另一个数组的任意特定位置上，你可以这么做：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = [&apos;two&apos;, &apos;three&apos;];</span><br><span class="line">var arr2 = [&apos;one&apos;, ...arr1, &apos;four&apos;, &apos;five&apos;];</span><br><span class="line"></span><br><span class="line">// [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;]</span><br></pre></td></tr></table></figure></li><li><strong>拷贝数组</strong><br>之前我们拷贝数组可以通过slice和concat等方法，有了对象扩展运算符我们也可以这样：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3];</span><br><span class="line">var arr2 = [...arr];</span><br><span class="line">arr2.push(4)</span><br><span class="line">console.log(&apos;arr2&apos;, arr2);</span><br><span class="line">console.log(&apos;arr&apos;, arr);</span><br></pre></td></tr></table></figure>结果如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr2 [ 1, 2, 3, 4 ]</span><br><span class="line">arr [ 1, 2, 3 ]</span><br></pre></td></tr></table></figure></li><li><strong>将arguments或者NodeList等伪数组转换为真正的数组</strong>。像这样：<br><code>[...arguments]</code>和<code>[...document.querySelectorAll(&#39;div&#39;)]</code></li></ul><p>还有其它一些应用不一一列举。需要注意的是：<br><div class="note primary"><p>展开运算符将数组“展开”成为不同的参数，所以任何可接收任意数量的参数的函数，都能够使用展开运算符来传参。比如：<code>Math.min(...[1,2,3]);</code></p></div></p><h2 id="Rest参数和对象展开运算符的关系"><a href="#Rest参数和对象展开运算符的关系" class="headerlink" title="Rest参数和对象展开运算符的关系"></a>Rest参数和对象展开运算符的关系</h2><ul><li>对象展开运算符就好比Rest参数的逆运算。</li><li>Rest参数是存在于形参当中，而对象展开运算符是不存在形参中的。</li><li>Rest参数作用于把传入的参数转化成数组，而对象扩展运算符是把不管是数组还是非数组对象扩展成一个个值。</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div class="note default"><p><a href="https://www.jianshu.com/p/50bcb376a419" target="_blank" rel="noopener">ES6 Rest参数</a><br><a href="https://www.jianshu.com/p/c5230c11781b" target="_blank" rel="noopener">ES6展开运算符的6种妙用</a></p></div> ]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;闲言&quot;&gt;&lt;a href=&quot;#闲言&quot; class=&quot;headerlink&quot; title=&quot;闲言&quot;&gt;&lt;/a&gt;闲言&lt;/h2&gt;&lt;p&gt;ES6是ECMAScript标准十余年来变动最大的一个版本，其中添加了许多新的语法特性，既有大家耳熟能详的Promise，也有闻所未闻的Pr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>通过css用div画出三角形</title>
    <link href="http://yoursite.com/post/2276870894.html"/>
    <id>http://yoursite.com/post/2276870894.html</id>
    <published>2019-01-19T04:41:13.000Z</published>
    <updated>2019-01-19T06:06:32.990Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闲言"><a href="#闲言" class="headerlink" title="闲言"></a>闲言</h2><p>通过css可以实现不同样式的三角形，其中的原理可以了解一下<a href="http://www.cnblogs.com/cchyao/archive/2010/07/12/1775846.html" target="_blank" rel="noopener">盒子模型</a>，闲言少叙，直接开始吧！</p><h2 id="基本入门"><a href="#基本入门" class="headerlink" title="基本入门"></a>基本入门</h2><p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Static Template&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .angel &#123;</span><br><span class="line">            display: inline-block;</span><br><span class="line">            border-width: 100px 100px 100px 100px;</span><br><span class="line">            border-color: red yellow green gray;</span><br><span class="line">            border-style: solid;</span><br><span class="line">            width: 50px;</span><br><span class="line">            height: 50px;</span><br><span class="line">            box-sizing: content-box;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;angel&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><br>效果图如下：<br><img src="/post/2276870894/1.png"><br>代码17行作用是使用标准的盒子模型，如果使用IE盒子模型（box-sizing：border-box;），就不会出现中间的空白方块，大家可以自行测试。当我们调整width和height为5px，效果图如下：<br><img src="/post/2276870894/2.png"><br>当width和height为0时，效果图如下<br><img src="/post/2276870894/3.png"><br>感觉像不像四个三角形拼接在一起，如果我们想要绿色的三角形，我们可以把其它三个边框的颜色设置成transparent,代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.angel &#123;</span><br><span class="line">            display: inline-block;</span><br><span class="line">            border-width: 100px 100px 100px 100px;</span><br><span class="line">            border-color: transparent transparent green transparent;</span><br><span class="line">            border-style: solid;</span><br><span class="line">            box-sizing: content-box;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><br>效果图如下：<br><img src="/post/2276870894/4.png"><br>但是其它边的颜色已经透明，但是所占区域还是存在的，我们可以审查一下元素，如图所示：<br><img src="/post/2276870894/5.png"><br>因此我们把上边框的border-width设置为0，得到下图：<br><img src="/post/2276870894/6.png"><br>是不是我们想要达到的效果。我们也可以设置左边或者右边的border为0，得到该三角形其中的一半（也是一个三角形），代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.angel &#123;</span><br><span class="line">            display: inline-block;</span><br><span class="line">            border-width: 0 100px 100px 0;</span><br><span class="line">            border-color: transparent transparent green transparent;</span><br><span class="line">            border-style: solid;</span><br><span class="line">            box-sizing: content-box;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><br>效果图如下：<br><img src="/post/2276870894/7.png"><br>因此通过调整border不同方向的width和color，我们就可以得到任意不同方向的三角形。</p><h2 id="实战练习"><a href="#实战练习" class="headerlink" title="实战练习"></a>实战练习</h2><h3 id="1-实现一个角度为30度的直角三角形"><a href="#1-实现一个角度为30度的直角三角形" class="headerlink" title="1. 实现一个角度为30度的直角三角形"></a>1. 实现一个角度为30度的直角三角形</h3><p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.angel &#123;</span><br><span class="line">            display: inline-block;</span><br><span class="line">            border-width: 0px 100px 173px 0px;</span><br><span class="line">            border-color: transparent transparent green transparent;</span><br><span class="line">            border-style: solid;</span><br><span class="line">            box-sizing: content-box;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><br>如图所示：<br><img src="/post/2276870894/8.png"></p><h3 id="2-实现一个带有边框的三角形"><a href="#2-实现一个带有边框的三角形" class="headerlink" title="2. 实现一个带有边框的三角形"></a>2. 实现一个带有边框的三角形</h3><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div class="note default"><p><a href="http://www.cnblogs.com/v-weiwang/p/5057588.html" target="_blank" rel="noopener">css如何将div画成三角形</a></p></div> ]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;闲言&quot;&gt;&lt;a href=&quot;#闲言&quot; class=&quot;headerlink&quot; title=&quot;闲言&quot;&gt;&lt;/a&gt;闲言&lt;/h2&gt;&lt;p&gt;通过css可以实现不同样式的三角形，其中的原理可以了解一下&lt;a href=&quot;http://www.cnblogs.com/cchyao/ar
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>http请求头origin和referer区别</title>
    <link href="http://yoursite.com/post/2885576345.html"/>
    <id>http://yoursite.com/post/2885576345.html</id>
    <published>2019-01-17T07:37:00.000Z</published>
    <updated>2019-01-19T03:07:08.172Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闲言"><a href="#闲言" class="headerlink" title="闲言"></a>闲言</h2><p>之前在做web项目中，每次使用chrome调试前端的时候经常会看到请求头header中经常会包含Referer和Origin字段，并且它俩的值有时长的还差不多，网上一查，它俩确实很相似，今天乘着闲暇的机会，整理一下它们各自的作用和区别。本人知识有限，如有错误欢迎留言指正。</p><h2 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h2><p>Referer其实应该是英文单词Referrer，不过拼错的人太多了，所以编写标准的人也就将错就错了。它是客户端请求头的一部分，当浏览器向web服务器发送请求的时候，<strong>一般会带上Referer</strong><font color="red">（不论是get请求还是post请求）</font>，告诉服务器我是从哪个页面链接过来的。比如说有个网址A：<code>https://mbd.baidu.com/newspage/data/landingsuper?context=%7B%22nid%22%3A%22news_1763945507961089360%22%7D&amp;n_type=0&amp;p_from=1</code>，A页面有个链接链接到了网站B：<code>https://mbd.baidu.com/newspage/data/landingsuper?context=%7B%22nid%22%3A%22news_9452777449866334360%22%7D&amp;n_type=0&amp;p_from=4</code>，如果你点击A页面的链接请求B页面，那么这时请求B页面的请求头中Referer就是A的网址：<code>https://mbd.baidu.com/newspage/data/landingsuper?context=%7B%22nid%22%3A%22news_9452777449866334360%22%7D&amp;n_type=0&amp;p_from=1</code>，你可以在B页面中调用浏览器的调试工具查看请求头验证一下。刚才说了<strong>一般会带上Referer</strong>，那么什么情况下不会带上呢？根据自己的验证和别人的分享，我总结出Referer的存在需要具备两个要素：</p><ol><li>浏览器（客户端）请求（服务器端请求的情况下，是不存在referer的，但是可以伪造header）</li><li>存在前导页，就是你的页面是从哪个页面链接过来的</li></ol><p>因此根据这两个要素，可以大致列举出不会带上Referer的几种情况如下：</p><ul><li>在浏览器内直接敲URL（没有前导页）</li><li>windows桌面上的超链接图标（原因同上）</li><li>浏览器内书签（同上）</li><li>第三方软件（如Word，Excel等）内容中的链接（不是浏览器）</li><li>使用JavaScript的Location.href或者是Location.replace()</li><li>SSL认证网站跳入(网站部署SSL证书后，可以通过在服务器设置301重定向让HTTP自动跳转到HTTPS，也可以通过设置JS跳转实现HTTP自动跳转到HTTPS）<br>然而在以下两种情况下，Referer不会被发送：</li></ul><ol><li>来源页面采用的协议为表示本地文件的 “file” 或者 “data” URI</li><li>当前请求页面采用的是非安全协议，而来源页面采用的是安全协议（HTTPS）</li></ol><div class="note danger"><p>Referer 首部可能暴露用户的浏览历史，涉及到用户的隐私问题。</p></div><h2 id="Referer的作用"><a href="#Referer的作用" class="headerlink" title="Referer的作用"></a>Referer的作用</h2><ul><li>统计访问这个页面从哪个前导页链接过来的次数</li><li>防止盗链，盗链的解释，请参考<a href="https://baike.baidu.com/item/%E7%9B%97%E9%93%BE?fr=aladdin" target="_blank" rel="noopener">百度百科</a>，当一个请求到达服务器，特别是CDN服务器的时候，CDN服务器可以根据该字段来判断来源站点是否是合作伙伴，或者是可信任的，然后再决定是否将资源返回给它</li><li>防止恶意请求，比如说只允许外部网站访问我的静态资源，对于动态资源，不允许从外部网站访问，这样在一定程度上可以避免CSRF攻击。当然了，依赖客户端的请求是很不可靠的，因为这个可以轻轻松松伪造。</li></ul><h2 id="Origin"><a href="#Origin" class="headerlink" title="Origin"></a>Origin</h2><p>请求首部字段 Origin 指示了请求来自于哪个站点。<strong>该字段仅指示服务器名称，并不包含任何路径信息</strong>。该首部<strong>只用于 CORS 请求或者 POST 请求</strong>。除了不包含路径信息，该字段与 Referer 首部字段相似。表现形式如下：<br><div class="note primary"><p>Origin: “”<br>Origin: <scheme> “://“ <host> [ “:” <port> ]</port></host></scheme></p></div><br>有时候将该字段的值置空是有用的，例如，资源由一个 data URL 指定</p><h2 id="Origin的作用"><a href="#Origin的作用" class="headerlink" title="Origin的作用"></a>Origin的作用</h2><p>从上面可以看出，其实referrer所能满足的要求，origin全部都能达到，事实上，origin的提出，本身就是在HTML5中跨域操作所引入的。 其具体流程是，当一个链接或者XMLHttpRequest去请求跨域操作，浏览器事实上的确向目标服务器发起了连接请求，并且携带这origin。 当服务器返回时，浏览器将检查response中是否包Access-Control-Allow-Origin字段，当缺少这个字段时，浏览器将abort，abort的意思是不显示，不产生事件，就好像没有请求过，甚至在network区域里面都看不到。 当存在这个header时，浏览器将检查当前请求所在域是否在这个access-control-allow-origin所允许的域内，如果是，继续下去，如果不存在，abort！</p><h2 id="两者主要区别"><a href="#两者主要区别" class="headerlink" title="两者主要区别"></a>两者主要区别</h2><ul><li>Origin不包含前导页任何的路径信息，但是Referer包含了前导页的路径信息，可能会透露出用户信息或者是用户浏览历史等隐私信息，因此Origin相对比Referer安全。</li><li>Referer不论是get请求和post请求都会存在，Origin当出现CORS时get和post请求都会出现，否则只会出现在post请求中。</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div class="note default"><p><a href="https://blog.csdn.net/fishmai/article/details/52388840" target="_blank" rel="noopener">Referer详解</a><br><a href="https://blog.csdn.net/zdavb/article/details/51161130" target="_blank" rel="noopener">彻底搞清referrer和origin</a></p></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;闲言&quot;&gt;&lt;a href=&quot;#闲言&quot; class=&quot;headerlink&quot; title=&quot;闲言&quot;&gt;&lt;/a&gt;闲言&lt;/h2&gt;&lt;p&gt;之前在做web项目中，每次使用chrome调试前端的时候经常会看到请求头header中经常会包含Referer和Origin字段，并且它俩的
      
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
      <category term="header" scheme="http://yoursite.com/tags/header/"/>
    
      <category term="Origin" scheme="http://yoursite.com/tags/Origin/"/>
    
      <category term="Referer" scheme="http://yoursite.com/tags/Referer/"/>
    
  </entry>
  
  <entry>
    <title>http状态码详解</title>
    <link href="http://yoursite.com/post/432560822.html"/>
    <id>http://yoursite.com/post/432560822.html</id>
    <published>2019-01-16T11:13:29.000Z</published>
    <updated>2019-01-18T15:57:57.455Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1xx：指示信息，表示请求被接受，正在处理"><a href="#1xx：指示信息，表示请求被接受，正在处理" class="headerlink" title="1xx：指示信息，表示请求被接受，正在处理"></a>1xx：指示信息，表示请求被接受，正在处理</h2><ol><li>101 Switching Protocols：服务器将遵从客户端的请求转换到另外一种协议（HTTP1.1）</li></ol><h2 id="2xx：成功，表示请求正常处理完毕"><a href="#2xx：成功，表示请求正常处理完毕" class="headerlink" title="2xx：成功，表示请求正常处理完毕"></a>2xx：成功，表示请求正常处理完毕</h2><ol><li>200 OK（成功）:客户端请求成功</li><li>204 No Content（无内容）：服务器成功处理了请求，但没有返回任何内容。</li><li>206 Partial Content（部分内容）：客户发送了一个带有Range头的GET请求，服务器完成了它（代表服务器根据Range头返回了部分内容）</li></ol><h2 id="3xx：重定向，完成请求必须进行跟进一步的操作"><a href="#3xx：重定向，完成请求必须进行跟进一步的操作" class="headerlink" title="3xx：重定向，完成请求必须进行跟进一步的操作"></a>3xx：重定向，完成请求必须进行跟进一步的操作</h2><ol><li>301 Moved Permanently（永久移动）：所请求的页面已经永久转移至新的url，服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新url</li><li>302 Moved Provisionally（临时移动）：服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求</li><li>304 Not Modified（未修改）：自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容</li></ol><h2 id="4xx：客户端错误，请求有语法错误或者请求无法实现从而导致服务器无法处理请求"><a href="#4xx：客户端错误，请求有语法错误或者请求无法实现从而导致服务器无法处理请求" class="headerlink" title="4xx：客户端错误，请求有语法错误或者请求无法实现从而导致服务器无法处理请求"></a>4xx：客户端错误，请求有语法错误或者请求无法实现从而导致服务器无法处理请求</h2><ol><li>400 Bad Request（错误请求）：服务器不理解请求的语法</li><li>401 Unauthorized（请求未授权）：请求要求身份验证即发送请求需要Http的认证信息。 对于需要登录的网页，服务器可能返回此响应。</li><li>403 Forbidden（禁止访问）：请求资源的访问被拒绝</li><li>404 Not Found（没发现）：请求资源不存在</li></ol><h2 id="5xx：服务器处理请求出错-服务器未能实现合法的请求"><a href="#5xx：服务器处理请求出错-服务器未能实现合法的请求" class="headerlink" title="5xx：服务器处理请求出错,服务器未能实现合法的请求"></a>5xx：服务器处理请求出错,服务器未能实现合法的请求</h2><ol><li>500 Internal Server Error（服务器端错误）：服务器发生不可预期的错误</li><li>503 Server Unavailable（服务器不可用）：服务器目前无法使用（由于超载或停机维护）； 通常，这只是暂时状态</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div class="note default"><p><a href="https://blog.csdn.net/hangmine/article/details/79010025" target="_blank" rel="noopener">常见的HTTP状态码(HTTP Status Code)说明</a><br><a href="https://segmentfault.com/a/1190000008900299" target="_blank" rel="noopener">HTTP 最强资料大全</a><br><a href="http://www.cnblogs.com/scyitgz/p/5216031.html" target="_blank" rel="noopener">一鸣先生 手稿</a><br><a href="https://blog.csdn.net/Rnger/article/details/82425961" target="_blank" rel="noopener">状态码401 和 403</a></p></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1xx：指示信息，表示请求被接受，正在处理&quot;&gt;&lt;a href=&quot;#1xx：指示信息，表示请求被接受，正在处理&quot; class=&quot;headerlink&quot; title=&quot;1xx：指示信息，表示请求被接受，正在处理&quot;&gt;&lt;/a&gt;1xx：指示信息，表示请求被接受，正在处理&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>深入理解vue的computed和watch区别</title>
    <link href="http://yoursite.com/post/21176862.html"/>
    <id>http://yoursite.com/post/21176862.html</id>
    <published>2019-01-12T03:19:58.000Z</published>
    <updated>2019-02-26T12:13:24.230Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闲言"><a href="#闲言" class="headerlink" title="闲言"></a>闲言</h2><h2 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h2><p>监控计算属性的变化（被动变化），主要是根据计算属性中所依赖值发生变化，从而得到新的值，计算属性可以不再data属性中申明，如果计算属性依赖的属性发生了变化，就会运行该computed函数得到计算属性新值，反之如果需要用到计算属性，就会从缓存里面去取，因此比methods性能更佳，其次Vue中的计算属性都是同步的，如果需要异步我们得依赖于<a href="https://github.com/foxbenjaminfox/vue-async-computed" target="_blank" rel="noopener">vue-async-computed</a>。<br>   <img src="/post/21176862/1.png"><br>   代码示例：<br>      <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;p id=&quot;app&quot;&gt;&#123; &#123; fullName &#125; &#125;&lt;/p&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var vm = new Vue(&#123;  </span><br><span class="line">        el: &apos;#app&apos;,  </span><br><span class="line">        data: &#123;  </span><br><span class="line">            firstName: &apos;Foo&apos;,  </span><br><span class="line">            lastName: &apos;Bar&apos;,  </span><br><span class="line">        &#125;,  </span><br><span class="line">        computed: &#123;  </span><br><span class="line">            fullName: function () &#123;  </span><br><span class="line">                return this.firstName + &apos; &apos; + this.lastName  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">      </span><br></pre></td></tr></table></figure><br>代码中fullName就是计算属性，它所依赖的属性为firstName和lastName，如果它们发生任何变化，都会调用该计算属性函数，如果依赖没有变化，则不会调用，当需要fullName时候，会从缓存里面取。<br>计算属性默认是只有ES6的getter，当然可以在需要的时候自己设定ES6的setter:<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//...</span><br><span class="line">computed: &#123;</span><br><span class="line">    fullName: &#123;</span><br><span class="line">        // getter</span><br><span class="line">        get: function () &#123;</span><br><span class="line">            return this.firstName + &apos; &apos; + this.lastName</span><br><span class="line">        &#125;,</span><br><span class="line">        // setter</span><br><span class="line">        set: function (newValue) &#123;</span><br><span class="line">            var names = newValue.split(&apos; &apos;)</span><br><span class="line">            this.firstName = names[0]</span><br><span class="line">            this.lastName = names[names.length - 1]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure><br>那么问题来了，既然computed有setter方法，不知道大家是不是和我想法一样，这样setter不就可以取代了watch了吗？关于这个疑问，我觉得有几点可以说明：</p><ol><li>watch函数可以传来两个参数，一个是新值一个是旧值，而计算属性函数只有一个新值的参数，虽然可以使用其它办法来获取旧值。   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line"> return &#123;</span><br><span class="line">     frontPoints: 0    </span><br><span class="line">   &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> watch: &#123;</span><br><span class="line">     frontPoints(newValue, oldValue) &#123;</span><br><span class="line">         console.log(newValue)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">      </span><br></pre></td></tr></table></figure></li><li>watch可以监控对象属性的变化,而setter不能是对象属性，个人觉得这一点是关键。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">　　return &#123;</span><br><span class="line">　　　　bet: &#123;</span><br><span class="line">　　　　　　pokerState: 53,</span><br><span class="line">　　　　　　pokerHistory: &apos;local&apos;</span><br><span class="line">　　　　&#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">watch: &#123;</span><br><span class="line">　　bet: &#123;</span><br><span class="line">　　　　handler(newValue, oldValue) &#123;</span><br><span class="line">　　　　　　console.log(newValue)</span><br><span class="line">　　　　&#125;,</span><br><span class="line">　　　　deep: true</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>        <h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2>监控data中属性的变化（主动变化），如果该属性值变化，则会调用该watch函数，主要用来修改其它属性变量或处理一些复杂逻辑和异步操作；该变量必须是data中有的属性。<img src="/post/21176862/2.png">代码示例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">        el: &apos;#app&apos;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            firstName: &apos;Foo&apos;,</span><br><span class="line">            lastName: &apos;Bar&apos;,</span><br><span class="line">            fullName: &apos;Foo Bar&apos;</span><br><span class="line">        &#125;,</span><br><span class="line">        watch: &#123;</span><br><span class="line">            firstName: function (val) &#123;</span><br><span class="line">                this.fullName = val + &apos; &apos; + this.lastName</span><br><span class="line">            &#125;,</span><br><span class="line">            lastName: function (val) &#123;</span><br><span class="line">                this.fullName = this.firstName + &apos; &apos; + val</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">   </span><br></pre></td></tr></table></figure>当watch中的firstName和lastName值发生变化时，就会调用各自的函数。<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div class="note default"><p><a href="https://www.w3cplus.com/vue/methods-computed-and-watchers-in-vue-js.html" target="_blank" rel="noopener">Vue中的方法，属性计算和观察者</a><br><a href="https://www.w3cplus.com/vue/vue-computed-intro.html" target="_blank" rel="noopener">Vue 2.0学习笔记： Vue中的computed属性</a><br>(<a href="https://blog.csdn.net/webxiaoma/article/details/72626439" target="_blank" rel="noopener">https://blog.csdn.net/webxiaoma/article/details/72626439</a>)<br>   <a href="https://www.cnblogs.com/widgetbox/p/8954162.html" target="_blank" rel="noopener">vue中methods、watch、computed之间的差别对比以及适用场景</a><br>   <a href="https://blog.csdn.net/zhumengzj/article/details/78742069" target="_blank" rel="noopener">vuejs - 如何对某个对象的属性进行watch监听？</a><br>   <a href="https://blog.csdn.net/u014298440/article/details/82942680" target="_blank" rel="noopener">Vue使用watch监听一个对象中的属性</a><br>   <a href="https://www.w3cplus.com/vue/methods-computed-and-watchers-in-vue-js.html" target="_blank" rel="noopener">Vue中的方法，属性计算和观察者</a></p></div> </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;闲言&quot;&gt;&lt;a href=&quot;#闲言&quot; class=&quot;headerlink&quot; title=&quot;闲言&quot;&gt;&lt;/a&gt;闲言&lt;/h2&gt;&lt;h2 id=&quot;computed&quot;&gt;&lt;a href=&quot;#computed&quot; class=&quot;headerlink&quot; title=&quot;computed&quot;
      
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>细说table和div布局的优缺点</title>
    <link href="http://yoursite.com/post/4067833097.html"/>
    <id>http://yoursite.com/post/4067833097.html</id>
    <published>2019-01-09T10:51:00.000Z</published>
    <updated>2019-01-14T12:58:13.345Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闲言"><a href="#闲言" class="headerlink" title="闲言"></a>闲言</h2><p>一开始接触前端时候使用的是table布局，当时感觉table布局真的很方便，并且可以使用DW软件来自动生成；但是随着所开发的页面复杂化和对性能的要求越来越高，table布局渐渐的展现出来它的不足了；现在table的布局方式已经被div+css布局方式替代了，但是也不排除市面上还有一些老系统仍然是table布局；下面针对这两种布局方式（<strong><em>table布局</em></strong>和<strong><em>div+css布局</em></strong>）来详细的讲解一下它们各自的优缺点。如有描述不正确，欢迎留言指正。</p><h2 id="div-css布局优缺点"><a href="#div-css布局优缺点" class="headerlink" title="div+css布局优缺点"></a>div+css布局优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>可以通过css样式给框架进行功能强大的属性设置以及给网页的局部进行任意的定位，制作出来的页面浏览速度较快，</li><li>页面的风格可以通过修改单独的css文件进行随意的修改和更新。</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>对于开发者来说可能不熟悉css的开发人员来说上手比较慢，开发时间可能比较长。</p><h2 id="table布局优缺点"><a href="#table布局优缺点" class="headerlink" title="table布局优缺点"></a>table布局优缺点</h2><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ol><li>开发时间短（使用DW开发速度快）。</li><li>纯table各浏览器不会有兼容问题。</li><li>内容可自适应。</li><li>在搜索引擎排名能靠前。</li></ol><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ol><li>如果布局变更，需要重新开发，灵活性比较差。</li><li>如果table里有div ul 等，可能会出现浏览器兼容问题。</li><li>加载速度慢<div class="note primary"><p>由于html文件中的table标签的浏览速度较慢，所以，使用嵌套表格的方法来布局网页框架会使网页浏览的速度变慢。因为table是中的内容是自适应的，为了自适应，它要计算嵌套最深的节点以满足自适应，所以有可能会有一断时间出现空白才显示。所以是会有问题的。 </p></div></li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div class="note default"><p><a href="https://www.cnblogs.com/nwj-0613/p/4775854.html" target="_blank" rel="noopener">HTML中table和div布局的优缺点</a></p></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;闲言&quot;&gt;&lt;a href=&quot;#闲言&quot; class=&quot;headerlink&quot; title=&quot;闲言&quot;&gt;&lt;/a&gt;闲言&lt;/h2&gt;&lt;p&gt;一开始接触前端时候使用的是table布局，当时感觉table布局真的很方便，并且可以使用DW软件来自动生成；但是随着所开发的页面复杂化和对性
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用hexo-admin随时随地发布hexo博客</title>
    <link href="http://yoursite.com/post/2981499989.html"/>
    <id>http://yoursite.com/post/2981499989.html</id>
    <published>2019-01-08T16:58:55.000Z</published>
    <updated>2019-02-26T12:12:35.982Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闲言"><a href="#闲言" class="headerlink" title="闲言"></a>闲言</h2><p>之前通过github page和hexo框架搭建了一个博客系统，一开始在自己的电脑上写完hexo博客，然后敲点命令发布到github上，过程感觉不算太麻烦；但是如果当我们换一台电脑或者是你在公司或者网吧的时候一时兴起想写博客，那么你就必须要在手头上的电脑中配置hexo环境所需要的一系列依赖（其中的麻烦你懂的），才能写博客发布你的博客。为了能够更方便的随时随地都能写博客发布博客,我使用hexo-admin搭建了一个在线的hexo博客后台管理系统，下面我就来详细的讲解一下我的搭建流程，希望能够给大家带来帮助，如果描述有误，欢迎大家留言指正。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>本人自己有一台阿里云服务器，但是考虑到稳定性和安全性等问题，最后将hexo的静态页面部署github-pages上。现在我的需求有：</p><ol><li>拥有在线编辑博客的后台</li><li>本地机器同时也可以编辑发布博客</li><li>本地和线上要保持同步</li><li>由于我使用的是next的主题，也希望修改的主题功能也可以方便的同步</li></ol><h2 id="我所用到的工具"><a href="#我所用到的工具" class="headerlink" title="我所用到的工具"></a>我所用到的工具</h2><ol><li>hexo-admin</li><li>阿里云服务器</li><li>coding.net一个可以创建免费私有仓库的git服务器</li><li>github page</li></ol><h2 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h2><ol><li>首先安装hexo-admin管理包，我的博客工程名称为blog，我就以blog来说，进入blog文件夹通过<code>npm install hexo-admin --save</code>（如果被墙可以使用<a href="https://npm.taobao.org/" target="_blank" rel="noopener">淘宝NPM镜像</a>）或者是<code>yarn add hexo-admin --save</code>（不懂yarn命令的可以自行百度）来安装hexo-admin。安装成功后我们可以使用命令<code>hexo s -d</code>来启动博客，之后访问‘localhost:4000/admin’打开博客管理系统，界面如下图：<img src="/post/2981499989/hexo_admin.png"></li><li>本地搭建后台管理系统成功，但是这样每个人都能访问我们的管理系统，因此我们需要为管理系统添加登录功能；为了实现该功能我们需要在<code>_config.yml</code>添加hexo-admin的admin选项，如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">admin:</span><br><span class="line">  username: </span><br><span class="line">  password_hash: </span><br><span class="line">  secret: my super secret phrase</span><br><span class="line">  deployCommand: &apos;./hexo-deploy.sh&apos;</span><br></pre></td></tr></table></figure><code>username</code>是用户名可以自己任意起名，<code>password_hash</code>需要在步骤1中打开的博客管理系统中的Settings中获取，如下图：<img src="/post/2981499989/hexo_admin1.png">按图示点击，可以进入到以下界面：<img src="/post/2981499989/password.png">界面中画上红色圈的是我们填入的，可以任意填，之后你会看到username和password_hash会自动生成，入蓝色圈圈所示，把蓝色框中的值复制到对应的我们在<code>_config.yml</code>配置的admin选项中即可，如果配置成功，这时你重新打开管理系统就可以看到登录窗口，输入用户名和密码即可登录成功,如下图：<img src="/post/2981499989/login.png">对于<code>deployCommand</code>是你需要填入的执行脚本路径，该脚本是需要自己创建的，作用是在线发布博客（点击博客后台管理系统中Deploy选项的Deploy按钮即可一键部署)，其原理是通过node.js中的<code>child_process.spawn</code>来执行我们创建的部署脚本程序，脚本程序<code>hexo-deploy.sh</code>代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">echo &quot;start&quot;</span><br><span class="line">./server-upload.sh</span><br><span class="line">hexo clean </span><br><span class="line">hexo g</span><br><span class="line">gulp</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>上面代码的第4、5、7行是基本的hexo部署命令，不在累述，第6行是gulp命令，专门用来压缩静态资源文件（不懂的可以自行百度，这里不在累述），代码第3行引入了另一个脚本<code>server-upload.sh</code>，该脚本专门同步coding.net仓库中的源代码和merge代码，源码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &apos;merge&apos;</span><br><span class="line">git pull origin master</span><br><span class="line">git add .</span><br><span class="line">git commit -m &apos;upload source code&apos;</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure></li><li>为了保持博客的源代码线上线下同步，我把它托管到了coding.net中，这样就可以通过git来保持源代码的一致性（不要忘了给你的本地电脑和线上服务器配置公钥，否则每次都需要输入用户名和密码）；具体配置可以自行百度，这里不再累述。</li><li>我的博客用的是next主题。由于主题也是通过git clone下来的，一开始我是把next主题也一起同步到coding.net仓库中，但是当我再重新从我的仓库中git clone我的博客后，运行<code>hexo s -d</code>命令是会报错误<code>no the layout named index.html</code>，网上查了一下，必须要独立的git clone才能没有问题。因此我单独为next主题创建了coding.net仓库，之后通过在blog/themes文件夹下git clone主题即可。如果我修改了next主题，也需要及时的merge到coding.net仓库中，这样才能保持next主题同步。还有一点需要注意的是主题文件修改之后，你再进行复制主题文件，你会惊奇的发现，你复制的主题文件又回到了你修改之前的状态，因此这点需要主题，必要的时候你需要对比文件手动修改。</li><li>有了本地的后台管理系统，也把博客和主题源代码托管到coding.net中了，但是我们还需要把它部署到线上，这样我们才能随时随地可以通过浏览器访问；我是通过阿里云服务器搭建的hexo系统，具体搭建步骤和本地一模一样。就是通过git命令把博客和主题源代码clone下来，之后通过<code>npm install</code>或者<code>yarn install</code>命令下载依赖包，这样就搭建成功，是不是很简单！！！。一开始我们使用<code>hexo s -d</code>来启动我们的后台管理系统，但是如果我们退出该命令，或者命令窗口关闭，则该进程就关闭了，为了可以让博客管理系统可以一直在后台进程运行，可以使用<code>nohup hexo s -d -p 80 &amp;</code>命令，其中<code>-p 80</code>是指定端口号为80端口，也可以不写，因为默认是4000端口。</li><li>如果以上步骤都配置成功，就可以通过你的<code>服务器IP+端口号/admin</code>进入在线博客后台系统了，你可以编辑你的博客、添加博客等等，之后点击deploy按钮（可能等待时间会长一点）,如果部署成功会出现以下界面：<img src="/post/2981499989/deploy.png"><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div class="note default"><p><a href="https://www.jianshu.com/p/68e727dda16d" target="_blank" rel="noopener">如何优雅地发布Hexo博客</a><br><a href="https://segmentfault.com/a/1190000010434546" target="_blank" rel="noopener">hexo-admin后台管理博客</a><br><a href="https://www.jianshu.com/p/d174a6dc1b94" target="_blank" rel="noopener">Hexo博客SEO优化</a><br><a href="https://www.jianshu.com/p/393d067dba8d" target="_blank" rel="noopener">Hexo之next主题设置首页不显示全文(只显示预览)</a><br><a href="https://www.cnblogs.com/fengxiongZz/p/7707219.html" target="_blank" rel="noopener">使用Hexo+Github一步步搭建属于自己的博客（基础）</a><br><a href="https://segmentfault.com/a/1190000009544924" target="_blank" rel="noopener">hexo的next主题个性化配置教程</a><br><a href="https://www.jianshu.com/p/2f39de746900" target="_blank" rel="noopener">word在线预览功能</a><br><a href="https://github.com/MikeCoder/hexo-blog-encrypt/blob/master/ReadMe.zh.md" target="_blank" rel="noopener">hexo-blog-encrypt博客加密插件</a><br><a href="https://www.jianshu.com/p/1ff2fcbdd155" target="_blank" rel="noopener">Hexo博客第三方主题next进阶教程</a><br><a href="http://blog.heyuhua.xyz/2018/09/08/hexo+next%E8%AE%BE%E7%BD%AE%E7%9B%B8%E5%85%B3/" target="_blank" rel="noopener">hexo+next设置相关</a><br><a href="https://blog.csdn.net/blue_zy/article/details/79071414" target="_blank" rel="noopener">为你的Hexo加上评论系统-Valine</a></p></div></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;闲言&quot;&gt;&lt;a href=&quot;#闲言&quot; class=&quot;headerlink&quot; title=&quot;闲言&quot;&gt;&lt;/a&gt;闲言&lt;/h2&gt;&lt;p&gt;之前通过github page和hexo框架搭建了一个博客系统，一开始在自己的电脑上写完hexo博客，然后敲点命令发布到github上，过程
      
    
    </summary>
    
      <category term="hexo" scheme="http://yoursite.com/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
      <category term="next" scheme="http://yoursite.com/tags/next/"/>
    
      <category term="hexo-admin" scheme="http://yoursite.com/tags/hexo-admin/"/>
    
  </entry>
  
  <entry>
    <title>CSS左边固定右边自适应布局的几种方式</title>
    <link href="http://yoursite.com/post/915039209.html"/>
    <id>http://yoursite.com/post/915039209.html</id>
    <published>2019-01-06T04:56:19.000Z</published>
    <updated>2019-02-26T12:13:33.388Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闲言"><a href="#闲言" class="headerlink" title="闲言"></a>闲言</h2><p>在我们平常的布局中两栏布局是很常见的一种布局方式，并且对于两栏布局的实现方式也是层出不穷；之前忙于工作和happy，没有时间去整理这方面知识，今天抽空总结一下，一方面可以提升和巩固自己的知识，二者也可以分享给大伙儿，更易于大家的理解和掌握。由于自己的水平有限，如果文章有任何问题，欢迎大家积极留言评论指正。</p><h2 id="1-根据css计算属性calc和display-inline-block实现左边固定右边自适应布局"><a href="#1-根据css计算属性calc和display-inline-block实现左边固定右边自适应布局" class="headerlink" title="1. 根据css计算属性calc和display:inline-block实现左边固定右边自适应布局"></a>1. 根据css计算属性calc和display:inline-block实现左边固定右边自适应布局</h2><iframe src="https://codesandbox.io/embed/2wq24y4wnp" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p> 在display:inline-block中，如何有换行符和空格符的话，就会产生inline-block元素之前有间隙，因此我们在父元素中把字符的font-size设为0。关于inlin-block去间隙问题可以参考：<a href="https://blog.csdn.net/gladys_1111/article/details/77279985" target="_blank" rel="noopener">inline-block布局产生间隙的原因及解决办法（水平、垂直）</a>。</p><h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3> <img src="/post/915039209/calc.png"><h2 id="2-根据css计算属性calc和display-float实现左边固定右边自适应布局"><a href="#2-根据css计算属性calc和display-float实现左边固定右边自适应布局" class="headerlink" title="2. 根据css计算属性calc和display:float实现左边固定右边自适应布局"></a>2. 根据css计算属性calc和display:float实现左边固定右边自适应布局</h2><iframe src="https://codesandbox.io/embed/1zr2zj18o4" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe><h2 id="3-根据float和margin实现左边固定右边自适应布局"><a href="#3-根据float和margin实现左边固定右边自适应布局" class="headerlink" title="3. 根据float和margin实现左边固定右边自适应布局"></a>3. 根据float和margin实现左边固定右边自适应布局</h2><iframe src="https://codesandbox.io/embed/yv48893om1" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe><h3 id="Note-1"><a href="#Note-1" class="headerlink" title="Note"></a>Note</h3><p>因为左边是浮动布局，右边是块布局，因此右边的div会自动充满一行；如果右边不设置margin，那么右边的一部分就和左边重叠，加入我们要给右边要设置左边边框，那么就达不到我们想要的效果。因此我们通过设置margin-left为左边的宽度，使得左右刚好不重叠。</p><h2 id="4-根据float和overflow实现左边固定右边自适应布局"><a href="#4-根据float和overflow实现左边固定右边自适应布局" class="headerlink" title="4. 根据float和overflow实现左边固定右边自适应布局"></a>4. 根据float和overflow实现左边固定右边自适应布局</h2><iframe src="https://codesandbox.io/embed/jp3x90vml3" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe><h3 id="Note-2"><a href="#Note-2" class="headerlink" title="Note"></a>Note</h3><p>这种实现方式感觉和上面一种实现方式很像，区别就是上面通过margin来处理重叠，而本方法是通过overflow：hidden来处理重叠，其原理是如果元素设置了overflow:hidden，这样就使它成为了一个BFC容器，因为BFC有个规则是：<strong>BFC的区域不会与float box重叠</strong>，正好是我想要的效果，关于BFC的特性可以参考：<a href="https://yaojunblog.cn/2018/12/12/BFC%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88/" target="_blank" rel="noopener">BFC到底是什么</a>，这种方式如果左边不设置宽度<strong>就可以实现左边自动撑开右边自适应布局</strong>。</p><h2 id="5-根据absolute和margin实现左边固定右边自适应布局"><a href="#5-根据absolute和margin实现左边固定右边自适应布局" class="headerlink" title="5. 根据absolute和margin实现左边固定右边自适应布局"></a>5. 根据absolute和margin实现左边固定右边自适应布局</h2><iframe src="https://codesandbox.io/embed/4xp8o28vo9" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe><h3 id="Note-3"><a href="#Note-3" class="headerlink" title="Note"></a>Note</h3><p>这种方式和float+margin方式很像，但是需要注意的是absolute的布局的父元素是非static元素。因此如果要使用这种方式，就需要把父元素设置成非static布局。</p><h2 id="6-仅根据absolute-left实现左边固定右边自适应布局"><a href="#6-仅根据absolute-left实现左边固定右边自适应布局" class="headerlink" title="6. 仅根据absolute+left实现左边固定右边自适应布局"></a>6. 仅根据absolute+left实现左边固定右边自适应布局</h2><iframe src="https://codesandbox.io/embed/2p8n6o0zyp" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe><h3 id="Note-4"><a href="#Note-4" class="headerlink" title="Note"></a>Note</h3><p>通过absolute布局让容器脱离的文档流，之后通过left属性进行偏移。</p><h2 id="7-display-table布局实现左边固定右边自适应布局"><a href="#7-display-table布局实现左边固定右边自适应布局" class="headerlink" title="7. display:table布局实现左边固定右边自适应布局"></a>7. display:table布局实现左边固定右边自适应布局</h2><iframe src="https://codesandbox.io/embed/kpj95xqmr" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe><h3 id="Note-5"><a href="#Note-5" class="headerlink" title="Note"></a>Note</h3><p>通过display:table可以使得元素拥有table的特性，因此可以通过table特性来达到其效果；其实我们也可以通过使用真正的table标签来实现其功能，在这里我就不累述了，有兴趣大家可以自己去实现以下。</p><h2 id="8-flex布局实现左边固定右边自适应布局"><a href="#8-flex布局实现左边固定右边自适应布局" class="headerlink" title="8. flex布局实现左边固定右边自适应布局"></a>8. flex布局实现左边固定右边自适应布局</h2><iframe src="https://codesandbox.io/embed/wo44m0zkol" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe><h3 id="Note-6"><a href="#Note-6" class="headerlink" title="Note"></a>Note</h3><p>flex布局正在改变传统的布局方式，让布局变得更简单。如果你对flex布局还是不很了解，请参考：<a href="https://www.w3cplus.com/css3/understanding-flexbox-everything-you-need-to-know.html" target="_blank" rel="noopener">理解Flexbox：你需要知道的一切</a></p><h3 id="兼容性-1"><a href="#兼容性-1" class="headerlink" title="兼容性"></a>兼容性</h3><img src="/post/915039209/flex.png"><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div class="note default"><p><a href="https://www.cnblogs.com/wangzhenyu666/p/7904522.html" target="_blank" rel="noopener">css实现两栏布局，左侧固定宽，右侧自适应的7中方法</a><br><a href="https://blog.csdn.net/gladys_1111/article/details/77279985" target="_blank" rel="noopener">inline-block布局产生间隙的原因及解决办法（水平、垂直）</a></p></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;闲言&quot;&gt;&lt;a href=&quot;#闲言&quot; class=&quot;headerlink&quot; title=&quot;闲言&quot;&gt;&lt;/a&gt;闲言&lt;/h2&gt;&lt;p&gt;在我们平常的布局中两栏布局是很常见的一种布局方式，并且对于两栏布局的实现方式也是层出不穷；之前忙于工作和happy，没有时间去整理这方面知识
      
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="两栏布局" scheme="http://yoursite.com/tags/%E4%B8%A4%E6%A0%8F%E5%B8%83%E5%B1%80/"/>
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>vue双向绑定原理笔录</title>
    <link href="http://yoursite.com/post/2399374655.html"/>
    <id>http://yoursite.com/post/2399374655.html</id>
    <published>2019-01-01T12:35:10.000Z</published>
    <updated>2019-02-21T14:55:41.835Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闲言"><a href="#闲言" class="headerlink" title="闲言"></a>闲言</h2><script src="https://gist.github.com/xtylovesyj/210e36aec55099b2ff9dcc4b1448e536.js"></script><script src="https://gist.github.com/xtylovesyj/6f3ab21ccc2421b0dfec94b0b2ce3bbe.js"></script><script src="https://gist.github.com/xtylovesyj/2b3a69b52b97f7f1176ef1b766dfd3bc.js"></script><h2 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">export class Observer &#123;</span><br><span class="line">  value: any;</span><br><span class="line">  dep: Dep;</span><br><span class="line">  vmCount: number; // number of vms that have this object as root $data</span><br><span class="line"></span><br><span class="line">  constructor (value: any) &#123;</span><br><span class="line">    this.value = value</span><br><span class="line">    this.dep = new Dep()</span><br><span class="line">    this.vmCount = 0</span><br><span class="line">    def(value, &apos;__ob__&apos;, this)</span><br><span class="line">    if (Array.isArray(value)) &#123;</span><br><span class="line">      if (hasProto) &#123;</span><br><span class="line">        protoAugment(value, arrayMethods)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        copyAugment(value, arrayMethods, arrayKeys)</span><br><span class="line">      &#125;</span><br><span class="line">      this.observeArray(value)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Walk through all properties and convert them into</span><br><span class="line">   * getter/setters. This method should only be called when</span><br><span class="line">   * value type is Object.</span><br><span class="line">   */</span><br><span class="line">  walk (obj: Object) &#123;</span><br><span class="line">    const keys = Object.keys(obj)</span><br><span class="line">    for (let i = 0; i &lt; keys.length; i++) &#123;</span><br><span class="line">      defineReactive(obj, keys[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Observe a list of Array items.</span><br><span class="line">   */</span><br><span class="line">  observeArray (items: Array&lt;any&gt;) &#123;</span><br><span class="line">    for (let i = 0, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">      observe(items[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> /**</span><br><span class="line"> * Augment a target Object or Array by intercepting</span><br><span class="line"> * the prototype chain using __proto__</span><br><span class="line"> */</span><br><span class="line">function protoAugment (target, src: Object) &#123;</span><br><span class="line">  /* eslint-disable no-proto */</span><br><span class="line">  target.__proto__ = src</span><br><span class="line">  /* eslint-enable no-proto */</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Augment a target Object or Array by defining</span><br><span class="line"> * hidden properties.</span><br><span class="line"> */</span><br><span class="line">/* istanbul ignore next */</span><br><span class="line">function copyAugment (target: Object, src: Object, keys: Array&lt;string&gt;) &#123;</span><br><span class="line">  for (let i = 0, l = keys.length; i &lt; l; i++) &#123;</span><br><span class="line">    const key = keys[i]</span><br><span class="line">    def(target, key, src[key])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;                                      </span><br></pre></td></tr></table></figure>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Attempt to create an observer instance for a value,</span><br><span class="line"> * returns the new observer if successfully observed,</span><br><span class="line"> * or the existing observer if the value already has one.</span><br><span class="line"> */</span><br><span class="line">export function observe (value: any, asRootData: ?boolean): Observer | void &#123;</span><br><span class="line">  if (!isObject(value) || value instanceof VNode) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  let ob: Observer | void</span><br><span class="line">  if (hasOwn(value, &apos;__ob__&apos;) &amp;&amp; value.__ob__ instanceof Observer) &#123;</span><br><span class="line">    ob = value.__ob__</span><br><span class="line">  &#125; else if (</span><br><span class="line">    shouldObserve &amp;&amp;</span><br><span class="line">    !isServerRendering() &amp;&amp;</span><br><span class="line">    (Array.isArray(value) || isPlainObject(value)) &amp;&amp;</span><br><span class="line">    Object.isExtensible(value) &amp;&amp;</span><br><span class="line">    !value._isVue</span><br><span class="line">  ) &#123;</span><br><span class="line">    ob = new Observer(value)</span><br><span class="line">  &#125;</span><br><span class="line">  if (asRootData &amp;&amp; ob) &#123;</span><br><span class="line">    ob.vmCount++</span><br><span class="line">  &#125;</span><br><span class="line">  return ob</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Define a reactive property on an Object.</span><br><span class="line"> */</span><br><span class="line">export function defineReactive (</span><br><span class="line">  obj: Object,</span><br><span class="line">  key: string,</span><br><span class="line">  val: any,</span><br><span class="line">  customSetter?: ?Function,</span><br><span class="line">  shallow?: boolean</span><br><span class="line">) &#123;</span><br><span class="line">  const dep = new Dep()</span><br><span class="line"></span><br><span class="line">  const property = Object.getOwnPropertyDescriptor(obj, key)</span><br><span class="line">  if (property &amp;&amp; property.configurable === false) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // cater for pre-defined getter/setters</span><br><span class="line">  const getter = property &amp;&amp; property.get</span><br><span class="line">  const setter = property &amp;&amp; property.set</span><br><span class="line">  if ((!getter || setter) &amp;&amp; arguments.length === 2) &#123;</span><br><span class="line">    val = obj[key]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  let childOb = !shallow &amp;&amp; observe(val)</span><br><span class="line">  Object.defineProperty(obj, key, &#123;</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true,</span><br><span class="line">    get: function reactiveGetter () &#123;</span><br><span class="line">      const value = getter ? getter.call(obj) : val</span><br><span class="line">      if (Dep.target) &#123;</span><br><span class="line">        dep.depend()</span><br><span class="line">        if (childOb) &#123;</span><br><span class="line">          childOb.dep.depend()</span><br><span class="line">          if (Array.isArray(value)) &#123;</span><br><span class="line">            dependArray(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return value</span><br><span class="line">    &#125;,</span><br><span class="line">    set: function reactiveSetter (newVal) &#123;</span><br><span class="line">      const value = getter ? getter.call(obj) : val</span><br><span class="line">      /* eslint-disable no-self-compare */</span><br><span class="line">      if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">        return</span><br><span class="line">      &#125;</span><br><span class="line">      /* eslint-enable no-self-compare */</span><br><span class="line">      if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; customSetter) &#123;</span><br><span class="line">        customSetter()</span><br><span class="line">      &#125;</span><br><span class="line">      // #7981: for accessor properties without setter</span><br><span class="line">      if (getter &amp;&amp; !setter) return</span><br><span class="line">      if (setter) &#123;</span><br><span class="line">        setter.call(obj, newVal)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        val = newVal</span><br><span class="line">      &#125;</span><br><span class="line">      childOb = !shallow &amp;&amp; observe(newVal)</span><br><span class="line">      dep.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Collect dependencies on array elements when the array is touched, since</span><br><span class="line"> * we cannot intercept array element access like property getters.</span><br><span class="line"> */</span><br><span class="line">function dependArray (value: Array&lt;any&gt;) &#123;</span><br><span class="line">  for (let e, i = 0, l = value.length; i &lt; l; i++) &#123;</span><br><span class="line">    e = value[i]</span><br><span class="line">    e &amp;&amp; e.__ob__ &amp;&amp; e.__ob__.dep.depend()</span><br><span class="line">    if (Array.isArray(e)) &#123;</span><br><span class="line">      dependArray(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h2> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"> let uid = 0</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * A dep is an observable that can have multiple</span><br><span class="line"> * directives subscribing to it.</span><br><span class="line"> */</span><br><span class="line">export default class Dep &#123;</span><br><span class="line">  static target: ?Watcher;</span><br><span class="line">  id: number;</span><br><span class="line">  subs: Array&lt;Watcher&gt;;</span><br><span class="line"></span><br><span class="line">  constructor () &#123;</span><br><span class="line">    this.id = uid++</span><br><span class="line">    this.subs = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addSub (sub: Watcher) &#123;</span><br><span class="line">    this.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  removeSub (sub: Watcher) &#123;</span><br><span class="line">    remove(this.subs, sub)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  depend () &#123;</span><br><span class="line">    if (Dep.target) &#123;</span><br><span class="line">      Dep.target.addDep(this)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  notify () &#123;</span><br><span class="line">    // stabilize the subscriber list first</span><br><span class="line">    const subs = this.subs.slice()</span><br><span class="line">    if (process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; !config.async) &#123;</span><br><span class="line">      // subs aren&apos;t sorted in scheduler if not running async</span><br><span class="line">      // we need to sort them now to make sure they fire in correct</span><br><span class="line">      // order</span><br><span class="line">      subs.sort((a, b) =&gt; a.id - b.id)</span><br><span class="line">    &#125;</span><br><span class="line">    for (let i = 0, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].update()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// The current target watcher being evaluated.</span><br><span class="line">// This is globally unique because only one watcher</span><br><span class="line">// can be evaluated at a time.</span><br><span class="line">Dep.target = null</span><br><span class="line">const targetStack = []</span><br><span class="line"></span><br><span class="line">export function pushTarget (target: ?Watcher) &#123;</span><br><span class="line">  targetStack.push(target)</span><br><span class="line">  Dep.target = target</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export function popTarget () &#123;</span><br><span class="line">  targetStack.pop()</span><br><span class="line">  Dep.target = targetStack[targetStack.length - 1]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br></pre></td><td class="code"><pre><span class="line">let uid = 0</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * A watcher parses an expression, collects dependencies,</span><br><span class="line"> * and fires callback when the expression value changes.</span><br><span class="line"> * This is used for both the $watch() api and directives.</span><br><span class="line"> */</span><br><span class="line">export default class Watcher &#123;</span><br><span class="line">  vm: Component;</span><br><span class="line">  expression: string;</span><br><span class="line">  cb: Function;</span><br><span class="line">  id: number;</span><br><span class="line">  deep: boolean;</span><br><span class="line">  user: boolean;</span><br><span class="line">  lazy: boolean;</span><br><span class="line">  sync: boolean;</span><br><span class="line">  dirty: boolean;</span><br><span class="line">  active: boolean;</span><br><span class="line">  deps: Array&lt;Dep&gt;;</span><br><span class="line">  newDeps: Array&lt;Dep&gt;;</span><br><span class="line">  depIds: SimpleSet;</span><br><span class="line">  newDepIds: SimpleSet;</span><br><span class="line">  before: ?Function;</span><br><span class="line">  getter: Function;</span><br><span class="line">  value: any;</span><br><span class="line"></span><br><span class="line">  constructor (</span><br><span class="line">    vm: Component,</span><br><span class="line">    expOrFn: string | Function,</span><br><span class="line">    cb: Function,</span><br><span class="line">    options?: ?Object,</span><br><span class="line">    isRenderWatcher?: boolean</span><br><span class="line">  ) &#123;</span><br><span class="line">    this.vm = vm</span><br><span class="line">    if (isRenderWatcher) &#123;</span><br><span class="line">      vm._watcher = this</span><br><span class="line">    &#125;</span><br><span class="line">    vm._watchers.push(this)</span><br><span class="line">    // options</span><br><span class="line">    if (options) &#123;</span><br><span class="line">      this.deep = !!options.deep</span><br><span class="line">      this.user = !!options.user</span><br><span class="line">      this.lazy = !!options.lazy</span><br><span class="line">      this.sync = !!options.sync</span><br><span class="line">      this.before = options.before</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.deep = this.user = this.lazy = this.sync = false</span><br><span class="line">    &#125;</span><br><span class="line">    this.cb = cb</span><br><span class="line">    this.id = ++uid // uid for batching</span><br><span class="line">    this.active = true</span><br><span class="line">    this.dirty = this.lazy // for lazy watchers</span><br><span class="line">    this.deps = []</span><br><span class="line">    this.newDeps = []</span><br><span class="line">    this.depIds = new Set()</span><br><span class="line">    this.newDepIds = new Set()</span><br><span class="line">    this.expression = process.env.NODE_ENV !== &apos;production&apos;</span><br><span class="line">      ? expOrFn.toString()</span><br><span class="line">      : &apos;&apos;</span><br><span class="line">    // parse expression for getter</span><br><span class="line">    if (typeof expOrFn === &apos;function&apos;) &#123;</span><br><span class="line">      this.getter = expOrFn</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this.getter = parsePath(expOrFn)</span><br><span class="line">      if (!this.getter) &#123;</span><br><span class="line">        this.getter = noop</span><br><span class="line">        process.env.NODE_ENV !== &apos;production&apos; &amp;&amp; warn(</span><br><span class="line">          `Failed watching path: &quot;$&#123;expOrFn&#125;&quot; ` +</span><br><span class="line">          &apos;Watcher only accepts simple dot-delimited paths. &apos; +</span><br><span class="line">          &apos;For full control, use a function instead.&apos;,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    this.value = this.lazy</span><br><span class="line">      ? undefined</span><br><span class="line">      : this.get()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Evaluate the getter, and re-collect dependencies.</span><br><span class="line">   */</span><br><span class="line">  get () &#123;</span><br><span class="line">    pushTarget(this)</span><br><span class="line">    let value</span><br><span class="line">    const vm = this.vm</span><br><span class="line">    try &#123;</span><br><span class="line">      value = this.getter.call(vm, vm)</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      if (this.user) &#123;</span><br><span class="line">        handleError(e, vm, `getter for watcher &quot;$&#123;this.expression&#125;&quot;`)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        throw e</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      // &quot;touch&quot; every property so they are all tracked as</span><br><span class="line">      // dependencies for deep watching</span><br><span class="line">      if (this.deep) &#123;</span><br><span class="line">        traverse(value)</span><br><span class="line">      &#125;</span><br><span class="line">      popTarget()</span><br><span class="line">      this.cleanupDeps()</span><br><span class="line">    &#125;</span><br><span class="line">    return value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Add a dependency to this directive.</span><br><span class="line">   */</span><br><span class="line">  addDep (dep: Dep) &#123;</span><br><span class="line">    const id = dep.id</span><br><span class="line">    if (!this.newDepIds.has(id)) &#123;</span><br><span class="line">      this.newDepIds.add(id)</span><br><span class="line">      this.newDeps.push(dep)</span><br><span class="line">      if (!this.depIds.has(id)) &#123;</span><br><span class="line">        dep.addSub(this)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Clean up for dependency collection.</span><br><span class="line">   */</span><br><span class="line">  cleanupDeps () &#123;</span><br><span class="line">    let i = this.deps.length</span><br><span class="line">    while (i--) &#123;</span><br><span class="line">      const dep = this.deps[i]</span><br><span class="line">      if (!this.newDepIds.has(dep.id)) &#123;</span><br><span class="line">        dep.removeSub(this)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    let tmp = this.depIds</span><br><span class="line">    this.depIds = this.newDepIds</span><br><span class="line">    this.newDepIds = tmp</span><br><span class="line">    this.newDepIds.clear()</span><br><span class="line">    tmp = this.deps</span><br><span class="line">    this.deps = this.newDeps</span><br><span class="line">    this.newDeps = tmp</span><br><span class="line">    this.newDeps.length = 0</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Subscriber interface.</span><br><span class="line">   * Will be called when a dependency changes.</span><br><span class="line">   */</span><br><span class="line">  update () &#123;</span><br><span class="line">    /* istanbul ignore else */</span><br><span class="line">    if (this.lazy) &#123;</span><br><span class="line">      this.dirty = true</span><br><span class="line">    &#125; else if (this.sync) &#123;</span><br><span class="line">      this.run()</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      queueWatcher(this)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Scheduler job interface.</span><br><span class="line">   * Will be called by the scheduler.</span><br><span class="line">   */</span><br><span class="line">  run () &#123;</span><br><span class="line">    if (this.active) &#123;</span><br><span class="line">      const value = this.get()</span><br><span class="line">      if (</span><br><span class="line">        value !== this.value ||</span><br><span class="line">        // Deep watchers and watchers on Object/Arrays should fire even</span><br><span class="line">        // when the value is the same, because the value may</span><br><span class="line">        // have mutated.</span><br><span class="line">        isObject(value) ||</span><br><span class="line">        this.deep</span><br><span class="line">      ) &#123;</span><br><span class="line">        // set new value</span><br><span class="line">        const oldValue = this.value</span><br><span class="line">        this.value = value</span><br><span class="line">        if (this.user) &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">            this.cb.call(this.vm, value, oldValue)</span><br><span class="line">          &#125; catch (e) &#123;</span><br><span class="line">            handleError(e, this.vm, `callback for watcher &quot;$&#123;this.expression&#125;&quot;`)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          this.cb.call(this.vm, value, oldValue)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Evaluate the value of the watcher.</span><br><span class="line">   * This only gets called for lazy watchers.</span><br><span class="line">   */</span><br><span class="line">  evaluate () &#123;</span><br><span class="line">    this.value = this.get()</span><br><span class="line">    this.dirty = false</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Depend on all deps collected by this watcher.</span><br><span class="line">   */</span><br><span class="line">  depend () &#123;</span><br><span class="line">    let i = this.deps.length</span><br><span class="line">    while (i--) &#123;</span><br><span class="line">      this.deps[i].depend()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Remove self from all dependencies&apos; subscriber list.</span><br><span class="line">   */</span><br><span class="line">  teardown () &#123;</span><br><span class="line">    if (this.active) &#123;</span><br><span class="line">      // remove self from vm&apos;s watcher list</span><br><span class="line">      // this is a somewhat expensive operation so we skip it</span><br><span class="line">      // if the vm is being destroyed.</span><br><span class="line">      if (!this.vm._isBeingDestroyed) &#123;</span><br><span class="line">        remove(this.vm._watchers, this)</span><br><span class="line">      &#125;</span><br><span class="line">      let i = this.deps.length</span><br><span class="line">      while (i--) &#123;</span><br><span class="line">        this.deps[i].removeSub(this)</span><br><span class="line">      &#125;</span><br><span class="line">      this.active = false</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div class="note default"><p><a href="https://www.w3cplus.com/vue/vue-two-way-binding.html" target="_blank" rel="noopener">Vue的双向绑定原理及实现</a><br><a href="https://www.cnblogs.com/libin-1/p/6893712.html" target="_blank" rel="noopener"><font color="red">vue的双向绑定原理及实现</font></a></p></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;闲言&quot;&gt;&lt;a href=&quot;#闲言&quot; class=&quot;headerlink&quot; title=&quot;闲言&quot;&gt;&lt;/a&gt;闲言&lt;/h2&gt;&lt;script src=&quot;https://gist.github.com/xtylovesyj/210e36aec55099b2ff9dcc4b1
      
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
      <category term="双向绑定原理" scheme="http://yoursite.com/tags/%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>location.hash笔录</title>
    <link href="http://yoursite.com/post/2217945891.html"/>
    <id>http://yoursite.com/post/2217945891.html</id>
    <published>2019-01-01T08:45:00.000Z</published>
    <updated>2019-01-14T12:55:17.522Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闲言"><a href="#闲言" class="headerlink" title="闲言"></a>闲言</h2><p>在没有认识location.hash的时候，我每次实现在某个页面定位到特定的可视区域的时，都是通过scrollTop属性来实现。一次偶然的机会让我接触到了location.hash这个属性，才知道可以通过它很轻松的搞定我刚刚提到的需求；经过我进一步对location.hash的研究和了解，才知道这个属性的功能之强大，下面结合我所学的知识来总结一下我所认识的location.hash。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在浏览器的url中，如果存在“#”，那么第一个“#”字符本身以及它后面的任何字符称之为hash，可通过window.location.hash属性读取，并且“#”后面的字符会被浏览器解读为位置标识符。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ol><li><strong>“#”后面的值为位置标识符，它可以使得页面滚动到特定区域</strong>。比如说url为：<br> <code>http://www.example.com/index.html#print</code><br> print代表着index.html页面的位置，当浏览器解析该url时候，就会自动将print位置滚动到可视区域。<br> 为网页位置指定标识符，有两中方式：<br> 一. 使用锚点，比如<code>&lt;a name=&quot;print&quot;&gt;&lt;/a&gt;</code><br> 二. 使用id属性，比如<code>&lt;div id=&quot;print&quot;&gt;</code><br> 这样浏览器会自动将含有该锚点或者id的标签滚动到可视区域。</li><li><strong>hash（#）虽然出现在url中，但不会被包括在http请求中，它是用来指导浏览器动作的，对服务器端完全无用，因此，改变hash不会重新加载页面</strong>。比如说通过url访问：<code>https://www.baidu.com/#123</code>, 查看该请求头，如下图所示：<br><img src="/images/pasted-1.png" alt="upload successful">发现hash已经被浏览器请求忽略，已经不存在“#123”。</li><li><strong>可以为hash的改变添加HTML5的监听事件</strong>, <code>window.addEventListener(&quot;hashchange&quot;,funcRef,false)</code></li><li><strong>每一次改变hash(window.location.hash)，都会在浏览器访问历史中增加一个记录</strong>。</li></ol><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ol><li>基于hash位置标识符的特性，可以实现某些页面的置顶和置底功能等。</li><li>基于上面hash的2，3，4特性，可以实现SPA（单页面应用程序）的路由功能；实现原理可以参考大漠老是的<a href="https://www.w3cplus.com/javascript/front-end-routing.html" target="_blank" rel="noopener">前端路由一探</a>。<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div class="note default"><p><a href="https://www.cnblogs.com/yeer/archive/2013/01/21/2869827.html" target="_blank" rel="noopener">location.hash详解</a><br><a href="https://segmentfault.com/a/1190000014822765" target="_blank" rel="noopener">vue:路由实现原理</a></p></div></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;闲言&quot;&gt;&lt;a href=&quot;#闲言&quot; class=&quot;headerlink&quot; title=&quot;闲言&quot;&gt;&lt;/a&gt;闲言&lt;/h2&gt;&lt;p&gt;在没有认识location.hash的时候，我每次实现在某个页面定位到特定的可视区域的时，都是通过scrollTop属性来实现。一次偶然的机
      
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="hash" scheme="http://yoursite.com/tags/hash/"/>
    
      <category term="location" scheme="http://yoursite.com/tags/location/"/>
    
  </entry>
  
  <entry>
    <title>vue路由实现原理</title>
    <link href="http://yoursite.com/post/3881355925.html"/>
    <id>http://yoursite.com/post/3881355925.html</id>
    <published>2018-12-30T14:06:11.000Z</published>
    <updated>2019-02-21T14:56:19.792Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闲言"><a href="#闲言" class="headerlink" title="闲言"></a>闲言</h2><script src="https://gist.github.com/xtylovesyj/39c7326346a8a8562cd1d076beaf2547.js"></script><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div class="note default"><p><a href="https://www.w3cplus.com/javascript/front-end-routing.html" target="_blank" rel="noopener">前端路由一探</a><br><a href="https://www.cnblogs.com/yeer/archive/2013/01/21/2869827.html" target="_blank" rel="noopener">location.hash详解</a><br><a href="https://segmentfault.com/a/1190000014822765" target="_blank" rel="noopener">vue:路由实现原理</a></p></div> ]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;闲言&quot;&gt;&lt;a href=&quot;#闲言&quot; class=&quot;headerlink&quot; title=&quot;闲言&quot;&gt;&lt;/a&gt;闲言&lt;/h2&gt;&lt;script src=&quot;https://gist.github.com/xtylovesyj/39c7326346a8a8562cd1d076b
      
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>js继承那些事儿</title>
    <link href="http://yoursite.com/post/872881073.html"/>
    <id>http://yoursite.com/post/872881073.html</id>
    <published>2018-12-29T13:50:35.000Z</published>
    <updated>2019-02-26T12:11:22.245Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闲言"><a href="#闲言" class="headerlink" title="闲言"></a>闲言</h2><p>之前在公司做项目的时候用到了ES6中class的继承特性，和java等其它语言一样，只需要使用extends关键字就可以轻松搞定继承。那么ES6的继承原理和之前JS的继承原理是一样的吗？带着心中的疑惑，我通过查找相关资料和自己的总结写出了这篇文章。</p><h2 id="ES5继承"><a href="#ES5继承" class="headerlink" title="ES5继承"></a>ES5继承</h2><p>在js世界里，继承的方式有很多，有<strong>原型链继承</strong>、<strong>构造继承</strong>、<strong>实例继承</strong>、<strong>拷贝继承</strong>、<strong>组合继承</strong>和<strong>寄生组合继承</strong>等，它们的原理和优缺点可以参考<a href="https://www.cnblogs.com/humin/p/4556820.html" target="_blank" rel="noopener">JS实现继承的几种方式</a>，其中寄生组合继承是最优的一种继承方式，下面我重点介绍一下它的原理。<br><strong>寄生组合继承</strong>：主要通过<strong>原型链继承</strong>和<strong>构造继承</strong>进行结合，之后通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性。废话不多说，直接上代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个动物类</span><br><span class="line">function Animal (name) &#123;</span><br><span class="line">// 属性</span><br><span class="line">this.name = name || &apos;Animal&apos;;</span><br><span class="line">// 实例方法</span><br><span class="line">this.sleep = function()&#123;</span><br><span class="line">    console.log(this.name + &apos;正在睡觉！&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 原型方法</span><br><span class="line">Animal.prototype.eat = function(food) &#123;</span><br><span class="line">console.log(this.name + &apos;正在吃：&apos; + food);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Cat(name)&#123;</span><br><span class="line">Animal.call(this);</span><br><span class="line">this.name = name || &apos;Tom&apos;;</span><br><span class="line">&#125;</span><br><span class="line">(function()&#123;</span><br><span class="line">// 创建一个没有实例方法的类</span><br><span class="line">var Super = function()&#123;&#125;;</span><br><span class="line">Super.prototype = Animal.prototype;</span><br><span class="line">//将实例作为子类的原型</span><br><span class="line">Cat.prototype = new Super();</span><br><span class="line">Cat.prototype.constructor = Cat;</span><br><span class="line">&#125;)();</span><br><span class="line">// Test Code</span><br><span class="line">var cat = new Cat();</span><br><span class="line">console.log(cat.name);</span><br><span class="line">console.log(cat.sleep());</span><br><span class="line">console.log(cat instanceof Animal); // true</span><br><span class="line">console.log(cat instanceof Cat); //true</span><br><span class="line"> </span><br></pre></td></tr></table></figure><br> <strong>Note:</strong> <em>对于上面的代码，不知道有没有人和我产生同样的疑惑：为什么不直接把Cat.prototype = Animal.prototype呢？这样cat的实例不就可以拿到Animal中的原型属性或者方法了嘛，为什么需要通过实例化对象的方式呢？其实是因为如果使用Cat.prototype = Animal.prototype的方式，那么我如果通过Cat.prototype去增加一些原型属性和方法的话，那么继承Animal的其它子类也会相应的增加，因为Animal的子类共用一个原型，所以是我们不希望看到的。如果通过实例化对象，那么Animal的每个子类都有自己独立的原型，并且这个原型也指向了Animal的原型。</em><br> 由于上面的代码没有用到ES5中的新特新，下面我使用ES5Object.create和Object.defineProperties的特性（不懂的可以参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="noopener">MDN web docs</a>）重写改写代码，最终ES5寄生组合继承的代码如下。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">// 定义一个动物类</span><br><span class="line">function Animal (name) &#123;</span><br><span class="line">// 属性</span><br><span class="line">this.name = name || &apos;Animal&apos;;</span><br><span class="line">// 实例方法</span><br><span class="line">this.sleep = function()&#123;</span><br><span class="line">    console.log(this.name + &apos;正在睡觉！&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 原型方法</span><br><span class="line">Animal.prototype.eat = function(food) &#123;</span><br><span class="line">console.log(this.name + &apos;正在吃：&apos; + food);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function Cat(name)&#123;</span><br><span class="line">Animal.call(this);</span><br><span class="line">this.name = name || &apos;Tom&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//通过Object.create创建一个对象，</span><br><span class="line">并且这个对象的原型指向了Super.prototype,</span><br><span class="line">之后把这个对象增加了一个属性constructor,值为Cat</span><br><span class="line">Cat.prototpye = Object.create(Super.prototype,&#123;</span><br><span class="line">    constructor: &#123;</span><br><span class="line">        value: Cat,</span><br><span class="line">        enumerable: false,</span><br><span class="line">        writable: true,</span><br><span class="line">        configurable: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// Test Code</span><br><span class="line">var cat = new Cat();</span><br><span class="line">console.log(cat.name);</span><br><span class="line">console.log(cat.sleep());</span><br><span class="line">console.log(cat instanceof Animal); // true</span><br><span class="line">console.log(cat instanceof Cat); //true</span><br><span class="line"> </span><br></pre></td></tr></table></figure><br>看完代码之后，通过一张图来系统性的理解一下ES5的继承原理</p><img src="/post/872881073/es5.JPEG"><h2 id="ES6继承"><a href="#ES6继承" class="headerlink" title="ES6继承"></a>ES6继承</h2><p>如果想了解ES6的class的继承方式，就必须了解ES6代码通过babel转码后的源码，下面通过ES6创建一个class类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Parent &#123;</span><br><span class="line">    constructor(name,age)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    speakSomething()&#123;</span><br><span class="line">        console.log(&quot;I can speek chinese&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>经过转码后<br>    <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line"></span><br><span class="line">var _createClass = function () &#123;</span><br><span class="line">    function defineProperties(target, props) &#123;</span><br><span class="line">        for (var i = 0; i &lt; props.length; i++) &#123;</span><br><span class="line">            var descriptor = props[i];</span><br><span class="line">            descriptor.enumerable = descriptor.enumerable || false;</span><br><span class="line">            descriptor.configurable = true;</span><br><span class="line">            if (&quot;value&quot; in descriptor) descriptor.writable = true;</span><br><span class="line">            Object.defineProperty(target, descriptor.key, descriptor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return function (Constructor, protoProps, staticProps) &#123;</span><br><span class="line">        if (protoProps) defineProperties(Constructor.prototype, protoProps);</span><br><span class="line">        if (staticProps) defineProperties(Constructor, staticProps);</span><br><span class="line">        return Constructor;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line">function _classCallCheck(instance, Constructor) &#123;</span><br><span class="line">    if (!(instance instanceof Constructor)) &#123;</span><br><span class="line">        throw new TypeError(&quot;Cannot call a class as a function&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var Parent = function () &#123;</span><br><span class="line">    function Parent(name, age) &#123;</span><br><span class="line">        _classCallCheck(this, Parent);</span><br><span class="line"></span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _createClass(Parent, [&#123;</span><br><span class="line">        key: &quot;speakSomething&quot;,</span><br><span class="line">        value: function speakSomething() &#123;</span><br><span class="line">            console.log(&quot;I can speek chinese&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]);</span><br><span class="line"></span><br><span class="line">    return Parent;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure><br>可以看到ES6类的底层还是通过构造函数去创建的。通过ES6创建的类，是不允许你直接调用的。在ES5中，构造函数是可以直接运行的，比如Parent()。但是在ES6就不行。我们可以看到转码的构造函数中有_classCallCheck(this, Parent)语句,这句话是防止你通过构造函数直接运行的。你直接在ES6运行Parent(),这是不允许的,ES6中抛出Class constructor Parent cannot be invoked without ‘new’错误。转码后的会抛出Cannot call a class as a function.我觉得这样的规范挺好的，能够规范化类的使用方式。<br>转码中_createClass方法，它调用Object.defineProperty方法去给新创建的Parent添加各种属性。defineProperties(Constructor.prototype, protoProps)是给原型添加属性。如果你有静态属性，会直接添加到构造函数上defineProperties(Constructor, staticProps)。但是貌似并没有用到，下面可以证明。这两个流程走下来，其实就创建了一个类。</p><p>上面讲的是创建一个类的过程，那ES6如何实现继承的呢？还是上面的例子，这次我们给Parent添加静态属性，原型属性，内部属性<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Parent &#123;</span><br><span class="line">    static height = 12</span><br><span class="line">    constructor(name,age)&#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    speakSomething()&#123;</span><br><span class="line">        console.log(&quot;I can speek chinese&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.color = &apos;yellow&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//定义子类，继承父类</span><br><span class="line">class Child extends Parent &#123;</span><br><span class="line">    static width = 18</span><br><span class="line">    constructor(name,age)&#123;</span><br><span class="line">        super(name,age);</span><br><span class="line">    &#125;</span><br><span class="line">    coding()&#123;</span><br><span class="line">        console.log(&quot;I can code JS&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var c = new Child(&quot;job&quot;,30);</span><br><span class="line">c.coding()</span><br></pre></td></tr></table></figure><br>经过babel转码后<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line"></span><br><span class="line">var _createClass = function () &#123;</span><br><span class="line">    function defineProperties(target, props) &#123;</span><br><span class="line">        for (var i = 0; i &lt; props.length; i++) &#123;</span><br><span class="line">            var descriptor = props[i];</span><br><span class="line">            descriptor.enumerable = descriptor.enumerable || false;</span><br><span class="line">            descriptor.configurable = true;</span><br><span class="line">            if (&quot;value&quot; in descriptor) descriptor.writable = true;</span><br><span class="line">            Object.defineProperty(target, descriptor.key, descriptor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return function (Constructor, protoProps, staticProps) &#123;</span><br><span class="line">        if (protoProps) defineProperties(Constructor.prototype, protoProps);</span><br><span class="line">        if (staticProps) defineProperties(Constructor, staticProps);</span><br><span class="line">        return Constructor;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line">function _possibleConstructorReturn(self, call) &#123;</span><br><span class="line">    if (!self) &#123;</span><br><span class="line">        throw new ReferenceError(&quot;this hasn&apos;t been initialised - super() hasn&apos;t been called&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return call &amp;&amp; (typeof call === &quot;object&quot; || typeof call === &quot;function&quot;) ? call : self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _inherits(subClass, superClass) &#123;</span><br><span class="line">    if (typeof superClass !== &quot;function&quot; &amp;&amp; superClass !== null) &#123;</span><br><span class="line">        throw new TypeError(&quot;Super expression must either be null or a function, not &quot; + typeof superClass);</span><br><span class="line">    &#125;</span><br><span class="line">    subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, &#123;</span><br><span class="line">        constructor: &#123;</span><br><span class="line">            value: subClass,</span><br><span class="line">            enumerable: false,</span><br><span class="line">            writable: true,</span><br><span class="line">            configurable: true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function _classCallCheck(instance, Constructor) &#123;</span><br><span class="line">    if (!(instance instanceof Constructor)) &#123;</span><br><span class="line">        throw new TypeError(&quot;Cannot call a class as a function&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var Parent = function () &#123;</span><br><span class="line">    function Parent(name, age) &#123;</span><br><span class="line">        _classCallCheck(this, Parent);</span><br><span class="line"></span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _createClass(Parent, [&#123;</span><br><span class="line">        key: &quot;speakSomething&quot;,</span><br><span class="line">        value: function speakSomething() &#123;</span><br><span class="line">            console.log(&quot;I can speek chinese&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]);</span><br><span class="line"></span><br><span class="line">    return Parent;</span><br><span class="line">&#125;();</span><br><span class="line"></span><br><span class="line">Parent.height = 12;</span><br><span class="line"></span><br><span class="line">Parent.prototype.color = &apos;yellow&apos;;</span><br><span class="line"></span><br><span class="line">//定义子类，继承父类</span><br><span class="line"></span><br><span class="line">var Child = function (_Parent) &#123;</span><br><span class="line">    _inherits(Child, _Parent);</span><br><span class="line"></span><br><span class="line">    function Child(name, age) &#123;</span><br><span class="line">        _classCallCheck(this, Child);</span><br><span class="line"></span><br><span class="line">        return _possibleConstructorReturn(this, (Child.__proto__ || Object.getPrototypeOf(Child)).call(this, name, age));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _createClass(Child, [&#123;</span><br><span class="line">        key: &quot;coding&quot;,</span><br><span class="line">        value: function coding() &#123;</span><br><span class="line">            console.log(&quot;I can code JS&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]);</span><br><span class="line"></span><br><span class="line">    return Child;</span><br><span class="line">&#125;(Parent);</span><br><span class="line"></span><br><span class="line">Child.width = 18;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var c = new Child(&quot;job&quot;, 30);</span><br><span class="line">c.coding();</span><br></pre></td></tr></table></figure><br>我们可以看到，构造类的方法都没变，只是添加了<em>inherits核心方法来实现继承，下面我们把这个方法中主要的两段代码提取出来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">subClass.prototype = Object.create(superClass &amp;&amp; superClass.prototype, &#123;</span><br><span class="line">        constructor: &#123;</span><br><span class="line">            value: subClass,</span><br><span class="line">            enumerable: false,</span><br><span class="line">            writable: true,</span><br><span class="line">            configurable: true</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><br>这一段代码可以看出来，就和ES5中寄生组合继承中实现原型链继承的方式一样，这说明ES6实现原型上面的继承和之前js继承原理是一样的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;</span><br></pre></td></tr></table></figure><br>这段代码中的Object.setPrototypeOf方法可以让一个对象(第一个参数)的隐含指针_proto</em>指向另一个对象（第二个参数），这样处理是因为<br>现代 JavaScript 引擎优化属性访问所带来的特性的关系，更改对象的 [[Prototype]]在各个浏览器和 JavaScript 引擎上都是一个很慢的操作。其在更改继承的性能上的影响是微妙而又广泛的，这不仅仅限于 obj.<strong>proto</strong> = … 语句上的时间花费，而且可能会延伸到任何代码，那些可以访问任何[[Prototype]]已被更改的对象的代码。如果你关心性能，你应该避免设置一个对象的 [[Prototype]]。相反，你应该使用 Object.create()来创建带有你想要的[[Prototype]]的新对象<br>抛开性能，因此我们可以把上面代码简化为 <code>subClass.__proto__ = superClass</code><br>总结下来，_inherits核心思想就是下面两句<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">subClass.prototype.__proto__ = superClass.prototype</span><br><span class="line">subClass.__proto__ = superClass</span><br></pre></td></tr></table></figure><br>研究完代码，来一张图开森开森</p><img src="/post/872881073/es6.JPEG"><p>那为什么这样一倒腾，它就实现了继承了呢?<br>首先 subClass.prototype.<strong>proto</strong> = superClass.prototype保证了c instanceof Parent是true,Child的实例可以访问到父类的属性，包括内部属性，以及原型属性。其次，subClass.<strong>proto</strong> = superClass，保证了Child.height也能访问到，也就是静态方法。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div class="note default"><p><a href="https://www.cnblogs.com/humin/p/4556820.html" target="_blank" rel="noopener">js实现继承的几种方式</a><br><a href="https://segmentfault.com/a/1190000014798678" target="_blank" rel="noopener">ES6类以及继承的实现原理</a><br><a href="https://baijiahao.baidu.com/s?id=1593627663270143849&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">两张图看懂ES5和ES6中的继承，值得收藏</a></p></div> ]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;闲言&quot;&gt;&lt;a href=&quot;#闲言&quot; class=&quot;headerlink&quot; title=&quot;闲言&quot;&gt;&lt;/a&gt;闲言&lt;/h2&gt;&lt;p&gt;之前在公司做项目的时候用到了ES6中class的继承特性，和java等其它语言一样，只需要使用extends关键字就可以轻松搞定继承。那么E
      
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="es5" scheme="http://yoursite.com/tags/es5/"/>
    
      <category term="es6" scheme="http://yoursite.com/tags/es6/"/>
    
  </entry>
  
  <entry>
    <title>CSS3新特性</title>
    <link href="http://yoursite.com/post/2943041897.html"/>
    <id>http://yoursite.com/post/2943041897.html</id>
    <published>2018-12-24T15:14:59.000Z</published>
    <updated>2019-01-14T12:55:17.515Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闲言"><a href="#闲言" class="headerlink" title="闲言"></a>闲言</h2><p>CSS3大名应该所有涉及到前端开发的宝宝们都有不同程度的了解；CSS3是CSS（层叠样式表）技术的升级版本，于1999年开始制订，2001年5月23日W3C完成了CSS3的工作草案，主要包括盒子模型、列表模块、超链接方式、语言模块、背景和边框、文字特效、多栏布局等模块。但是如果让其说出CSS3中有哪些新特性，可能很多人一下子不知从何说起，或者是不能很完美的说出它的特性，下面就让我替你们总结一下CSS3有哪些骚特性。</p><h2 id="边框（border）"><a href="#边框（border）" class="headerlink" title="边框（border）"></a>边框（border）</h2><p>通过CSS3可以在不使用设计软件的情况下能够创建圆角边框、向矩形添加阴影、使用图片来绘制边框。</p><h3 id="border-radius（圆角边框）"><a href="#border-radius（圆角边框）" class="headerlink" title="border-radius（圆角边框）"></a>border-radius（圆角边框）</h3><h3 id="box-shadow（阴影）"><a href="#box-shadow（阴影）" class="headerlink" title="box-shadow（阴影）"></a>box-shadow（阴影）</h3><h3 id="border-image（图片边框）"><a href="#border-image（图片边框）" class="headerlink" title="border-image（图片边框）"></a>border-image（图片边框）</h3><h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><h3 id="疑点解答"><a href="#疑点解答" class="headerlink" title="疑点解答"></a>疑点解答</h3><h2 id="背景（background）"><a href="#背景（background）" class="headerlink" title="背景（background）"></a>背景（background）</h2><p>CSS3新增了多个新的背景属性，它们提供了对背景更强大的控制</p><h3 id="background-size（控制背景图片尺寸属性）"><a href="#background-size（控制背景图片尺寸属性）" class="headerlink" title="background-size（控制背景图片尺寸属性）"></a>background-size（控制背景图片尺寸属性）</h3><h3 id="background-origin（控制背景图片定位区域）"><a href="#background-origin（控制背景图片定位区域）" class="headerlink" title="background-origin（控制背景图片定位区域）"></a>background-origin（控制背景图片定位区域）</h3><h3 id="background-clip（控制背景的绘制区域）"><a href="#background-clip（控制背景的绘制区域）" class="headerlink" title="background-clip（控制背景的绘制区域）"></a>background-clip（控制背景的绘制区域）</h3><h3 id="兼容性-1"><a href="#兼容性-1" class="headerlink" title="兼容性"></a>兼容性</h3><h3 id="疑点解答-1"><a href="#疑点解答-1" class="headerlink" title="疑点解答"></a>疑点解答</h3><h2 id="文本效果（text-decoration）"><a href="#文本效果（text-decoration）" class="headerlink" title="文本效果（text decoration）"></a>文本效果（text decoration）</h2><p>CSS3新增多个文本特性，可以让我们设计出更好看的字体</p><h3 id="text-shadow（文本阴影）"><a href="#text-shadow（文本阴影）" class="headerlink" title="text-shadow（文本阴影）"></a>text-shadow（文本阴影）</h3><h3 id="text-wrap（文本换行规则）"><a href="#text-wrap（文本换行规则）" class="headerlink" title="text-wrap（文本换行规则）"></a>text-wrap（文本换行规则）</h3><h3 id="word-break（规定非中日韩文本的换行规则）"><a href="#word-break（规定非中日韩文本的换行规则）" class="headerlink" title="word-break（规定非中日韩文本的换行规则）"></a>word-break（规定非中日韩文本的换行规则）</h3><h3 id="text-overflow（规定当文本溢出包含元素时发生的事情）"><a href="#text-overflow（规定当文本溢出包含元素时发生的事情）" class="headerlink" title="text-overflow（规定当文本溢出包含元素时发生的事情）"></a>text-overflow（规定当文本溢出包含元素时发生的事情）</h3><h3 id="text-justify（规定当-text-align-设置为-“justify”-时所使用的对齐方法）"><a href="#text-justify（规定当-text-align-设置为-“justify”-时所使用的对齐方法）" class="headerlink" title="text-justify（规定当 text-align 设置为 “justify” 时所使用的对齐方法）"></a>text-justify（规定当 text-align 设置为 “justify” 时所使用的对齐方法）</h3><h3 id="text-emphasis（向元素的文本应用重点标记以及重点标记的前景色）"><a href="#text-emphasis（向元素的文本应用重点标记以及重点标记的前景色）" class="headerlink" title="text-emphasis（向元素的文本应用重点标记以及重点标记的前景色）"></a>text-emphasis（向元素的文本应用重点标记以及重点标记的前景色）</h3><h3 id="text-outline（规定文本的轮廓）"><a href="#text-outline（规定文本的轮廓）" class="headerlink" title="text-outline（规定文本的轮廓）"></a>text-outline（规定文本的轮廓）</h3><h3 id="punctuation-trim（规定是否对标点字符进行修剪）"><a href="#punctuation-trim（规定是否对标点字符进行修剪）" class="headerlink" title="punctuation-trim（规定是否对标点字符进行修剪）"></a>punctuation-trim（规定是否对标点字符进行修剪）</h3><h3 id="hanging-punctuation（规定标点字符是否位于线框之外）"><a href="#hanging-punctuation（规定标点字符是否位于线框之外）" class="headerlink" title="hanging-punctuation（规定标点字符是否位于线框之外）"></a>hanging-punctuation（规定标点字符是否位于线框之外）</h3><h2 id="引用外部字体（-font-face）"><a href="#引用外部字体（-font-face）" class="headerlink" title="引用外部字体（@font-face）"></a>引用外部字体（@font-face）</h2><h3 id="兼容性-2"><a href="#兼容性-2" class="headerlink" title="兼容性"></a>兼容性</h3><h3 id="疑点解答-2"><a href="#疑点解答-2" class="headerlink" title="疑点解答"></a>疑点解答</h3><h2 id="2D转换（2D-transform）"><a href="#2D转换（2D-transform）" class="headerlink" title="2D转换（2D transform）"></a>2D转换（2D transform）</h2><h3 id="translate-（元素平移）"><a href="#translate-（元素平移）" class="headerlink" title="translate()（元素平移）"></a>translate()（元素平移）</h3><h3 id="rotate-（元素旋转）"><a href="#rotate-（元素旋转）" class="headerlink" title="rotate()（元素旋转）"></a>rotate()（元素旋转）</h3><h3 id="scale-（元素缩放）"><a href="#scale-（元素缩放）" class="headerlink" title="scale() （元素缩放）"></a>scale() （元素缩放）</h3><h3 id="skew-（元素翻转）"><a href="#skew-（元素翻转）" class="headerlink" title="skew()（元素翻转）"></a>skew()（元素翻转）</h3><h3 id="matrix-（2D转换组合方法）"><a href="#matrix-（2D转换组合方法）" class="headerlink" title="matrix()（2D转换组合方法）"></a>matrix()（2D转换组合方法）</h3><h2 id="3D转换（3D-transform）"><a href="#3D转换（3D-transform）" class="headerlink" title="3D转换（3D transform）"></a>3D转换（3D transform）</h2><h3 id="translate3d-x-y-z-（定义-3D-转化）"><a href="#translate3d-x-y-z-（定义-3D-转化）" class="headerlink" title="translate3d(x,y,z)（定义 3D 转化）"></a>translate3d(x,y,z)（定义 3D 转化）</h3><h4 id="translateX-x-（定义-3D-转化，仅使用用于-X-轴的值）"><a href="#translateX-x-（定义-3D-转化，仅使用用于-X-轴的值）" class="headerlink" title="translateX(x)（定义 3D 转化，仅使用用于 X 轴的值）"></a>translateX(x)（定义 3D 转化，仅使用用于 X 轴的值）</h4><h4 id="translateY-y-（定义-3D-转化，仅使用用于-Y-轴的值）"><a href="#translateY-y-（定义-3D-转化，仅使用用于-Y-轴的值）" class="headerlink" title="translateY(y)（定义 3D 转化，仅使用用于 Y 轴的值）"></a>translateY(y)（定义 3D 转化，仅使用用于 Y 轴的值）</h4><h4 id="translateZ-z-（定义-3D-转化，仅使用用于-Z-轴的值）"><a href="#translateZ-z-（定义-3D-转化，仅使用用于-Z-轴的值）" class="headerlink" title="translateZ(z)（定义 3D 转化，仅使用用于 Z 轴的值）"></a>translateZ(z)（定义 3D 转化，仅使用用于 Z 轴的值）</h4><h3 id="scale3d-x-y-z-（定义-3D-缩放）"><a href="#scale3d-x-y-z-（定义-3D-缩放）" class="headerlink" title="scale3d(x,y,z)（定义 3D 缩放）"></a>scale3d(x,y,z)（定义 3D 缩放）</h3><h4 id="scaleX-x-（定义-3D-缩放，仅使用用于-X-轴的值）"><a href="#scaleX-x-（定义-3D-缩放，仅使用用于-X-轴的值）" class="headerlink" title="scaleX(x)（定义 3D 缩放，仅使用用于 X 轴的值）"></a>scaleX(x)（定义 3D 缩放，仅使用用于 X 轴的值）</h4><h4 id="scaleY-y-（定义-3D-缩放，仅使用用于-Y-轴的值）"><a href="#scaleY-y-（定义-3D-缩放，仅使用用于-Y-轴的值）" class="headerlink" title="scaleY(y)（定义 3D 缩放，仅使用用于 Y 轴的值）"></a>scaleY(y)（定义 3D 缩放，仅使用用于 Y 轴的值）</h4><h4 id="scaleZ-z-（定义-3D-缩放，仅使用用于-Z-轴的值）"><a href="#scaleZ-z-（定义-3D-缩放，仅使用用于-Z-轴的值）" class="headerlink" title="scaleZ(z)（定义 3D 缩放，仅使用用于 Z 轴的值）"></a>scaleZ(z)（定义 3D 缩放，仅使用用于 Z 轴的值）</h4><h3 id="rotate3d-x-y-z-（定义-3D-旋转）"><a href="#rotate3d-x-y-z-（定义-3D-旋转）" class="headerlink" title="rotate3d(x,y,z)（定义 3D 旋转）"></a>rotate3d(x,y,z)（定义 3D 旋转）</h3><h4 id="rotateX-x-（定义-3D-旋转，仅使用用于-X-轴的值）"><a href="#rotateX-x-（定义-3D-旋转，仅使用用于-X-轴的值）" class="headerlink" title="rotateX(x)（定义 3D 旋转，仅使用用于 X 轴的值）"></a>rotateX(x)（定义 3D 旋转，仅使用用于 X 轴的值）</h4><h4 id="rotateY-y-（定义-3D-旋转，仅使用用于-Y-轴的值）"><a href="#rotateY-y-（定义-3D-旋转，仅使用用于-Y-轴的值）" class="headerlink" title="rotateY(y)（定义 3D 旋转，仅使用用于 Y 轴的值）"></a>rotateY(y)（定义 3D 旋转，仅使用用于 Y 轴的值）</h4><h4 id="rotateZ-z-（定义-3D-旋转，仅使用用于-Z-轴的值）"><a href="#rotateZ-z-（定义-3D-旋转，仅使用用于-Z-轴的值）" class="headerlink" title="rotateZ(z)（定义 3D 旋转，仅使用用于 Z 轴的值）"></a>rotateZ(z)（定义 3D 旋转，仅使用用于 Z 轴的值）</h4><h3 id="matrix3d-n-n-n-n-n-n-n-n-n-n-n-n-n-n-n-n-（定义-3D-转换，使用-16-个值的-4x4-矩阵）"><a href="#matrix3d-n-n-n-n-n-n-n-n-n-n-n-n-n-n-n-n-（定义-3D-转换，使用-16-个值的-4x4-矩阵）" class="headerlink" title="matrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n) （定义 3D 转换，使用 16 个值的 4x4 矩阵）"></a>matrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n) （定义 3D 转换，使用 16 个值的 4x4 矩阵）</h3><h3 id="perspective-n-（定义-3D-转换元素的透视视图）"><a href="#perspective-n-（定义-3D-转换元素的透视视图）" class="headerlink" title="perspective(n)（定义 3D 转换元素的透视视图）"></a>perspective(n)（定义 3D 转换元素的透视视图）</h3><h2 id="过渡（transition）"><a href="#过渡（transition）" class="headerlink" title="过渡（transition）"></a>过渡（transition）</h2><p>通过 CSS3，我们可以在不使用 Flash 动画或 JavaScript 的情况下，当元素从一种样式变换为另一种样式时为元素添加效果</p><h2 id="动画（animation-amp-keyframes）"><a href="#动画（animation-amp-keyframes）" class="headerlink" title="动画（animation &amp; @keyframes）"></a>动画（animation &amp; @keyframes）</h2><h2 id="多列（multi-column）"><a href="#多列（multi-column）" class="headerlink" title="多列（multi-column）"></a>多列（multi-column）</h2><h3 id="column-count（规定元素应该被分隔的列数）"><a href="#column-count（规定元素应该被分隔的列数）" class="headerlink" title="column-count（规定元素应该被分隔的列数）"></a>column-count（规定元素应该被分隔的列数）</h3><h3 id="column-gap（规定列之间的间隔）"><a href="#column-gap（规定列之间的间隔）" class="headerlink" title="column-gap（规定列之间的间隔）"></a>column-gap（规定列之间的间隔）</h3><h3 id="column-rule（设置所有-column-rule-属性的简写属性）"><a href="#column-rule（设置所有-column-rule-属性的简写属性）" class="headerlink" title="column-rule（设置所有 column-rule-* 属性的简写属性）"></a>column-rule（设置所有 column-rule-* 属性的简写属性）</h3><h3 id="column-fill（规定如何填充列）"><a href="#column-fill（规定如何填充列）" class="headerlink" title="column-fill（规定如何填充列）"></a>column-fill（规定如何填充列）</h3><h3 id="column-rule-color（规定列之间规则的颜色）"><a href="#column-rule-color（规定列之间规则的颜色）" class="headerlink" title="column-rule-color（规定列之间规则的颜色）"></a>column-rule-color（规定列之间规则的颜色）</h3><h3 id="column-rule-style（规定列之间规则的样式）"><a href="#column-rule-style（规定列之间规则的样式）" class="headerlink" title="column-rule-style（规定列之间规则的样式）"></a>column-rule-style（规定列之间规则的样式）</h3><h3 id="column-rule-width（规定列之间规则的宽度）"><a href="#column-rule-width（规定列之间规则的宽度）" class="headerlink" title="column-rule-width（规定列之间规则的宽度）"></a>column-rule-width（规定列之间规则的宽度）</h3><h3 id="column-span（规定元素应该横跨的列数）"><a href="#column-span（规定元素应该横跨的列数）" class="headerlink" title="column-span（规定元素应该横跨的列数）"></a>column-span（规定元素应该横跨的列数）</h3><h3 id="column-width（规定列的宽度）"><a href="#column-width（规定列的宽度）" class="headerlink" title="column-width（规定列的宽度）"></a>column-width（规定列的宽度）</h3><h3 id="columns（规定设置-column-width-和-column-count-的简写属性）"><a href="#columns（规定设置-column-width-和-column-count-的简写属性）" class="headerlink" title="columns（规定设置 column-width 和 column-count 的简写属性）"></a>columns（规定设置 column-width 和 column-count 的简写属性）</h3><h2 id="用户界面"><a href="#用户界面" class="headerlink" title="用户界面"></a>用户界面</h2><h3 id="resize（规定是否可由用户对元素的尺寸进行调整）"><a href="#resize（规定是否可由用户对元素的尺寸进行调整）" class="headerlink" title="resize（规定是否可由用户对元素的尺寸进行调整）"></a>resize（规定是否可由用户对元素的尺寸进行调整）</h3><h3 id="box-sizing（允许您以确切的方式定义适应某个区域的具体内容）"><a href="#box-sizing（允许您以确切的方式定义适应某个区域的具体内容）" class="headerlink" title="box-sizing（允许您以确切的方式定义适应某个区域的具体内容）"></a>box-sizing（允许您以确切的方式定义适应某个区域的具体内容）</h3><h3 id="icon（为创作者提供使用图标化等价物来设置元素样式的能力）"><a href="#icon（为创作者提供使用图标化等价物来设置元素样式的能力）" class="headerlink" title="icon（为创作者提供使用图标化等价物来设置元素样式的能力）"></a>icon（为创作者提供使用图标化等价物来设置元素样式的能力）</h3><h3 id="outline-offset（对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓）"><a href="#outline-offset（对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓）" class="headerlink" title="outline-offset（对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓）"></a>outline-offset（对轮廓进行偏移，并在超出边框边缘的位置绘制轮廓）</h3><h3 id="appearance（允许您将元素设置为标准用户界面元素的外观）"><a href="#appearance（允许您将元素设置为标准用户界面元素的外观）" class="headerlink" title="appearance（允许您将元素设置为标准用户界面元素的外观）"></a>appearance（允许您将元素设置为标准用户界面元素的外观）</h3><h3 id="nav-down（规定在使用-arrow-down-导航键时向何处导航）"><a href="#nav-down（规定在使用-arrow-down-导航键时向何处导航）" class="headerlink" title="nav-down（规定在使用 arrow-down 导航键时向何处导航）"></a>nav-down（规定在使用 arrow-down 导航键时向何处导航）</h3><h3 id="nav-index（设置元素的-tab-键控制次序）"><a href="#nav-index（设置元素的-tab-键控制次序）" class="headerlink" title="nav-index（设置元素的 tab 键控制次序）"></a>nav-index（设置元素的 tab 键控制次序）</h3><h3 id="nav-left（规定在使用-arrow-left-导航键时向何处导航）"><a href="#nav-left（规定在使用-arrow-left-导航键时向何处导航）" class="headerlink" title="nav-left（规定在使用 arrow-left 导航键时向何处导航）"></a>nav-left（规定在使用 arrow-left 导航键时向何处导航）</h3><h3 id="nav-right（规定在使用-arrow-right-导航键时向何处导航）"><a href="#nav-right（规定在使用-arrow-right-导航键时向何处导航）" class="headerlink" title="nav-right（规定在使用 arrow-right 导航键时向何处导航）"></a>nav-right（规定在使用 arrow-right 导航键时向何处导航）</h3><h3 id="nav-up（规定在使用-arrow-up-导航键时向何处导航）"><a href="#nav-up（规定在使用-arrow-up-导航键时向何处导航）" class="headerlink" title="nav-up（规定在使用 arrow-up 导航键时向何处导航）"></a>nav-up（规定在使用 arrow-up 导航键时向何处导航）</h3><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>&gt;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;闲言&quot;&gt;&lt;a href=&quot;#闲言&quot; class=&quot;headerlink&quot; title=&quot;闲言&quot;&gt;&lt;/a&gt;闲言&lt;/h2&gt;&lt;p&gt;CSS3大名应该所有涉及到前端开发的宝宝们都有不同程度的了解；CSS3是CSS（层叠样式表）技术的升级版本，于1999年开始制订，2001年
      
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="css3新特性" scheme="http://yoursite.com/tags/css3%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>聊聊http的keepalive</title>
    <link href="http://yoursite.com/post/2582181702.html"/>
    <id>http://yoursite.com/post/2582181702.html</id>
    <published>2018-12-18T13:33:15.000Z</published>
    <updated>2019-01-14T12:55:17.507Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闲言"><a href="#闲言" class="headerlink" title="闲言"></a>闲言</h2><p>之前面试，有面试官问我http中的connection字段中有个keep-alive值，听说它可以保持http的长时间链接；那么问题来了，WebSocket也是保持长连接的，那么它们之间有什么区别？http的keep-alive可以代替webSocket的吗？经过查阅书籍和网上很多资料，终于有了答案。</p><h3 id="http连接类型"><a href="#http连接类型" class="headerlink" title="http连接类型"></a>http连接类型</h3><p>说到keep-alive之前，首先说一说http的连接类型</p><ul><li>短链接<br>所谓短连接，就是每次请求一个资源就建立连接，请求完成后连接立马关闭。每次请求都经过“创建tcp连接-&gt;请求资源-&gt;响应资源-&gt;释放连接”这样的过程。</li><li>长连接<br>所谓长连接(persistent connection)，就是只建立一次连接，多次资源请求都复用该连接，完成后关闭。要请求一个页面上的十张图，只需要建立一次tcp连接，然后依次请求十张图，等待资源响应，释放连接。</li><li>并行连接<br>所谓并行连接(multiple connections)，其实就是并发的短连接。</li></ul><img src="/post/2582181702/keepalive.png"><h2 id="http的keep-alive"><a href="#http的keep-alive" class="headerlink" title="http的keep-alive"></a>http的keep-alive</h2><p>说到keep-alive，其实有两个，一个是TCP的keepalive，另一个是http层面的keep-alive，两者由于发音相同可能容易让人混淆。其中http的keep-alive我们是接触比较多的。<br>在HTTP/1.0里，为了实现client到web-server能支持长连接，必须在HTTP请求头里显示指定Connection:keep-alive<br>在HTTP/1.1里，就默认是开启了keep-alive，要关闭keep-alive需要在HTTP请求头里显示指定Connection:close<br>现在大多数浏览器都默认是使用HTTP/1.1，所以keep-alive都是默认打开的。一旦client和server达成协议，那么长连接就建立好了。</p><h3 id="keep-alive达成协议过程"><a href="#keep-alive达成协议过程" class="headerlink" title="keep-alive达成协议过程"></a>keep-alive达成协议过程</h3><ul><li>client发出的HTTP请求头需要增加Connection:keep-alive字段</li><li>Web-Server端要能识别Connection:keep-alive字段，并且在http的response里指定Connection:keep-alive字段，告诉client，我能提供keep-alive服务，并且”应允”client我暂时不会关闭socket连接。</li></ul><h2 id="keep-alive和WebSocket的区别"><a href="#keep-alive和WebSocket的区别" class="headerlink" title="keep-alive和WebSocket的区别"></a>keep-alive和WebSocket的区别</h2><ol><li>keep-alive在一次 TCP连接中完成多个HTTP请求过程中每个请求仍然要单独要给服务器发header；WebSocket通过第一个HTTPrequest建立了TCP连接之后之后的交换数据都不需要再发HTTP request了。</li><li>keep-alive只是一种为了达到复用tcp连接的“协商”行为，双方并没有建立正真的连接会话，服务端也可以不认可，也可以随时（在任何一次请求完成后）关闭掉。WebSocket 不同，它本身就规定了是正真的、双工的长连接，两边都必须要维持住连接的状态。</li><li>http协议决定了keep-alive连接中浏览器端总是主动发起方，http的服务端总是被动的接受、响应请求，从不主动。WebSocket协议，在连接之后客户端服务端是完全平等的不存在主动被动之说。</li></ol><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><blockquote><p><a href="https://blog.csdn.net/xjbclz/article/details/53046627" target="_blank" rel="noopener">keep-alive和websocket有什么区别</a><br><a href="https://www.cnblogs.com/jtlgb/p/8805319.html" target="_blank" rel="noopener">理解HTTP之keep-alive</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;闲言&quot;&gt;&lt;a href=&quot;#闲言&quot; class=&quot;headerlink&quot; title=&quot;闲言&quot;&gt;&lt;/a&gt;闲言&lt;/h2&gt;&lt;p&gt;之前面试，有面试官问我http中的connection字段中有个keep-alive值，听说它可以保持http的长时间链接；那么问题来了，W
      
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
      <category term="keepalive" scheme="http://yoursite.com/tags/keepalive/"/>
    
  </entry>
  
  <entry>
    <title>数据可视化项目</title>
    <link href="http://yoursite.com/post/624146632.html"/>
    <id>http://yoursite.com/post/624146632.html</id>
    <published>2018-12-03T11:12:13.000Z</published>
    <updated>2019-02-25T14:48:01.431Z</updated>
    
    <content type="html"><![CDATA[<img src="/post/624146632/dashboard.PNG">]]></content>
    
    <summary type="html">
    
      
      
        &lt;img src=&quot;/post/624146632/dashboard.PNG&quot;&gt;
      
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="javascript" scheme="http://yoursite.com/tags/javascript/"/>
    
      <category term="d3.js" scheme="http://yoursite.com/tags/d3-js/"/>
    
      <category term="jquery" scheme="http://yoursite.com/tags/jquery/"/>
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
      <category term="gulp" scheme="http://yoursite.com/tags/gulp/"/>
    
  </entry>
  
</feed>
