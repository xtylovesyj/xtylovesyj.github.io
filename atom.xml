<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>姚俊的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-02-21T15:09:55.430Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>胖胖</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>蛋白质结构预测系统</title>
    <link href="http://yoursite.com/post/4196458460.html"/>
    <id>http://yoursite.com/post/4196458460.html</id>
    <published>2019-02-21T15:09:54.000Z</published>
    <updated>2019-02-21T15:09:55.430Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闲言"><a href="#闲言" class="headerlink" title="闲言"></a>闲言</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div class="note default"></div> ]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;闲言&quot;&gt;&lt;a href=&quot;#闲言&quot; class=&quot;headerlink&quot; title=&quot;闲言&quot;&gt;&lt;/a&gt;闲言&lt;/h2&gt;&lt;h2 id=&quot;参考文献&quot;&gt;&lt;a href=&quot;#参考文献&quot; class=&quot;headerlink&quot; title=&quot;参考文献&quot;&gt;&lt;/a&gt;参考文献&lt;/h
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>前端个人简历</title>
    <link href="http://yoursite.com/post/1972029411.html"/>
    <id>http://yoursite.com/post/1972029411.html</id>
    <published>2019-02-21T13:56:33.000Z</published>
    <updated>2019-02-21T15:03:29.975Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><p><strong>姓名：</strong>姚俊<br><strong>联系电话：</strong>15395716758<br><strong>民族：</strong>汉<br><strong>邮箱：</strong>459828686@qq.com<br><strong>婚姻状况：</strong>未婚<br><strong>居住地：</strong>杭州<br><strong>学历：</strong>硕士研究生<br><strong>目前状态：</strong>浙江网新前端开发<br><strong>专业：</strong>系统分析与集成<br><strong>工作经验：</strong>2年<br><strong>毕业院校：</strong>浙江工业大学<br><strong>求职意向：</strong>前端开发工程师</p><h2 id="专业技能"><a href="#专业技能" class="headerlink" title="专业技能"></a>专业技能</h2><ol><li>熟练掌握DIV+CSS3页面布局和重构，<a href="https://www.w3cplus.com/css3/understanding-flexbox-everything-you-need-to-know.html" target="_blank" rel="noopener">熟练掌握flexbox流布局</a>、熟练使用JavaScript、<a href="https://blog.csdn.net/erdfty/article/details/81363893" target="_blank" rel="noopener">熟悉W3C标准</a>，<a href="http://www.daqianduan.com/6549.html" target="_blank" rel="noopener">对HTML5语义化有一定的了解</a>。</li><li><a href="https://www.cnblogs.com/iceflorence/p/6646344.html" target="_blank" rel="noopener">熟练运用浏览器兼容技术</a>、熟练进行前端性能优化设计和<a href="http://web.jobbole.com/92875/" target="_blank" rel="noopener"><font color="red">前端安</font></a><a href="https://www.jianshu.com/p/9edcda47a04a" target="_blank" rel="noopener"><font color="black">全性</font></a><a href="https://segmentfault.com/a/1190000018073845" target="_blank" rel="noopener"><font color="green">优化</font></a><a href="https://segmentfault.com/a/1190000015275832?utm_source=tag-newest" target="_blank" rel="noopener"><font color="blue">设计</font></a>。</li><li>熟悉ECMA标准、熟练掌握和运用ES6语法、<a href="https://www.cnblogs.com/zhuanzhuanfe/p/7493433.html" target="_blank" rel="noopener">熟悉ES7、ES8语法</a>；熟练掌握DOM、BOM操作，熟悉闭包原理，熟悉面向对象JS编程，<a href="http://localhost:4000/post/872881073.html" target="_blank" rel="noopener">理解JS原型链的继承机制</a>。</li><li>熟悉<a href="https://yaojunblog.cn/post/4017532340.html" target="_blank" rel="noopener">https协议</a>实现基本原理以及<a href="https://yaojunblog.cn/post/3511927546.html" target="_blank" rel="noopener">http/2.0协议的特性</a>。</li><li>熟练使用Angular4、Vue2.0和Jquery等框架库，并有一定的项目经验，可以独立完成项目的开发。</li><li>研究过<a href="https://yaojunblog.cn/post/2399374655.html" target="_blank" rel="noopener">Vue双向绑定原理</a>和<a href="https://yaojunblog.cn/post/3881355925.html" target="_blank" rel="noopener">Vue路由原理</a>，并研究过相关源码。</li><li>熟练和掌握PrimeNG、iView和Bootstrap等UI框架的使用方法。</li><li>掌握Node.js，并拥有Node.js+Express框架后端开发项目经验。<br>有一定的Java语言以及后端开发框架基础，了解Java后端的简单开发流程，拥有简单的Java后端项目开发经验。</li></ol><h2 id="项目经历"><a href="#项目经历" class="headerlink" title="项目经历"></a>项目经历</h2><ol><li><strong>2017/09 - 至今   SOFIA后台系统开发 | 浙江网新恒天 | 前端开发</strong><br>项目背景：基于客户方美国某债券公司的多个监控管理系统，整合优化为一个公共系统，更为友好地为客户方实时展现状态信息以及业务流程的管理和控制。<br>主要技术或框架：Html5 | CSS3 | Angular4 | WebSocket | D3.js<br>主要负责模块：项目的搭建、通用组件的开发，和各个系统模块页面的实现。后期对系统的性能进行进一步优化以及对系统的安全性进行进一步的优化。</li><li><strong>2018/09 – 至今   蛋白质结构预测系统 | 校企合作 | 前端开发</strong><br>项目背景：为蛋白质结构预测算法设计人员提供监控管理界面，包括任务创建、实时监控和跟踪、数据的统计与分析、蛋白质三维可视化展示。<br>主要技术或框架：Nodejs | Express | Websocket | Vue | Highcharts<br>主要负责模块：前后端平台搭建、所有前端组件开发和前后端业务逻辑的实现，以及后期的维护和系统的性能以及安全性进行进一步的加强。</li><li><strong>2017/08 - 2017/09   大屏数据可视化 | 浙江网新恒天 | 前端开发</strong><br>项目背景：为了更为友好的给美国某债券公司客户方展现所需要的实时状态信息。<br>主要技术或框架：Html5 | CSS3 | Jquery| WebSocket | D3.js | gulp+webpack。<br>主要负责模块：前端框架的搭建、UI总体布局和各个监控模块的开发和部分d3图表的开发。</li><li><strong>2017/07 - 2017/08   PUMA Service系统 | 浙江网新恒天 | 前端开发</strong><br>项目背景：基于美国某债券公司客户方已经存在的监控系统，开发新的监控系统。<br>主要技术或框架：Html5 | CSS3 | Jquery | WebSocket | D3.js<br>主要负责模块：系统部分监控页面的开发和部分页面的优化。</li><li><strong>2016/05 - 2017/07   嵊州工程管理平台系统开发 | 校企合作 | Node.js后端开发</strong><br>项目背景：主要为嵊州某电力公司开发一套可以创建工程，管理工程和工程各个流程的审核以及工程造价的预算决算等功能的管理平台。<br>主要技术或框架：Node.js | Express | Jquery<br>主要负责模块：Node.js后端框架的搭建和各个功能模块后端接口的编写。</li><li><strong>2015/07 - 2016/10   嵊州工程管理平台系统开发 | 校企合作 | MES管理系统</strong><br>项目背景：基于苏州某智能机器人有限公司的智能车间工厂平台开发出一套web客户端系统，该系统包括智能仓储的优化控制、生产调度管理、车间实时监控看板以及人力资源管理等模块。<br>主要技术或框架：Angular | CSS3动画 | WebSocket | webpack打包优化<br>主要负责模块：前端框架的搭建以及原子组件、工具组件的开发和各个业务功能模块页面的实现和数据的集成；后期系统的优化和维护。</li></ol><h2 id="相关证书"><a href="#相关证书" class="headerlink" title="相关证书"></a>相关证书</h2><ol><li>浙江网新恒天软件公司部门优秀员工称号</li><li>国家奖学金</li><li>数学建模竞赛省赛三等奖</li><li>家庭仿真服务机器人国赛三等奖</li><li>省级优秀毕业生</li><li>大学英语四级</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本信息&quot;&gt;&lt;a href=&quot;#基本信息&quot; class=&quot;headerlink&quot; title=&quot;基本信息&quot;&gt;&lt;/a&gt;基本信息&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;姓名：&lt;/strong&gt;姚俊&lt;br&gt;&lt;strong&gt;联系电话：&lt;/strong&gt;15395716758&lt;br
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>基于Angular4的后台系统开发</title>
    <link href="http://yoursite.com/post/1289655291.html"/>
    <id>http://yoursite.com/post/1289655291.html</id>
    <published>2019-02-21T05:38:56.000Z</published>
    <updated>2019-02-21T13:34:25.065Z</updated>
    
    <content type="html"><![CDATA[<script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script><div id="hbe-security">  <div class="hbe-input-container">  <input type="password" class="hbe-form-control" id="pass" placeholder="enter password to read." />    <label for="pass">enter password to read.</label>    <div class="bottom-line"></div>  </div></div><div id="decryptionError" style="display: none;">Incorrect Password!</div><div id="noContentError" style="display: none;">No content to display!</div><div id="encrypt-blog" style="display:none">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</div><script src="/lib/crypto-js.js"></script><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      这是一篇加密的文章。
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
      <category term="angular4" scheme="http://yoursite.com/categories/javascript/angular4/"/>
    
    
      <category term="angular4" scheme="http://yoursite.com/tags/angular4/"/>
    
      <category term="polyfills" scheme="http://yoursite.com/tags/polyfills/"/>
    
      <category term="浏览器兼容性" scheme="http://yoursite.com/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>WebSocket心跳检测和断线重连方法</title>
    <link href="http://yoursite.com/post/3894638473.html"/>
    <id>http://yoursite.com/post/3894638473.html</id>
    <published>2019-02-19T08:14:03.000Z</published>
    <updated>2019-02-20T13:58:48.155Z</updated>
    
    <content type="html"><![CDATA[<div class="note default"><p><a href="https://www.cnblogs.com/tugenhua0707/p/8648044.html" target="_blank" rel="noopener">理解WebSocket心跳及重连机制</a><br><a href="https://www.jianshu.com/p/1047ea411648" target="_blank" rel="noopener">Websocket心跳重连</a><br><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html" target="_blank" rel="noopener">WebSocket教程</a><br><a href="https://blog.csdn.net/jkxqj/article/details/77848466" target="_blank" rel="noopener">给websocket加入心跳包防止自动断开连接</a></p></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;note default&quot;&gt;&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/tugenhua0707/p/8648044.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;理解WebSocket心跳及重连机制
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>D3.js框架使用总结</title>
    <link href="http://yoursite.com/post/2361688348.html"/>
    <id>http://yoursite.com/post/2361688348.html</id>
    <published>2019-02-19T02:51:22.000Z</published>
    <updated>2019-02-20T13:58:48.156Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前玩过Highcharts和Echarts可视化图形框架，绘制几种固定种类的、十分大众化的图表可谓是非常的方便，但是由于它们的封装程度太高了，对于如果希望开发脑海中任意想象到的图表来说就比较麻烦了；然而使用D3.js框架就比较容易了，D3.js 是基于数据操作文档的 JavaScript 库，通过 HTML、SVG 和 CSS 赋予数据以生命。D3 集强力的可视化组件与数据驱动型的 DOM 操作手法于一身，能最大限度地引出现代浏览器的性能，而不必束缚于特定的框架。D3 有一个很独特的功能：可以通过D3选择权器来获取页面中的DOM元素和添加删除DOM元素等，并能将数据绑定到 DOM 上，也就是绑定到文档上，绑定之后，当需要依靠这个数据才操作元素的时候，会很方便。 D3 提供了众多的 SVG 图形的生成器，它们都是只支持 SVG 的。因此，建议使用 SVG 画布。在 SVG 画布的预定义元素里，有六种基本图形：</p><ul><li>矩形</li><li>圆形</li><li>椭圆</li><li>线段</li><li>折线</li><li>多边形</li></ul><p>另外，还有一种比较特殊，也是功能最强的元素：</p><ul><li>路径</li></ul><h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>布局是 D3 中一个十分重要的概念。D3 与其它很多可视化工具不同，相对来说较底层，对初学者来说不太方便，但是一旦掌握了，就比其他工具更加得心应手。简单的来说布局的作用是：将不适合用于绘图的数据转换成了适合用于绘图的数据。D3 总共提供了 12 个布局分别为：</p><ol><li>饼状图（Pie）</li><li>力导向图（Force）</li><li>弦图（Chord）</li><li>树状图（Tree）</li><li>集群图（Cluster）</li><li>捆图（Bundle）</li><li>打包图（Pack）</li><li>直方图（Histogram）</li><li>分区图（Partition）</li><li>堆栈图（Stack）</li><li>矩阵树图（Treemap）</li><li>层级图（Hierarchy）</li></ol><p>12 个布局中，层级图（Hierarchy）不能直接使用。集群图、打包图、分区图、树状图、矩阵树图是由层级图扩展来的。如此一来，能够使用的布局是 11 个（有 5 个是由层级图扩展而来）。这些布局的作用都是将某种数据转换成另一种数据，而转换后的数据是利于可视化的。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div class="note default"><p><a href="http://d3.decembercafe.org/index.html" target="_blank" rel="noopener">Learning D3.js</a><br><a href="https://www.jianshu.com/p/1c22523624f6" target="_blank" rel="noopener">D3.js初体验</a></p></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;之前玩过Highcharts和Echarts可视化图形框架，绘制几种固定种类的、十分大众化的图表可谓是非常的方便，但是由于它们的封装程度太高
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>webpack4教程</title>
    <link href="http://yoursite.com/post/1413616213.html"/>
    <id>http://yoursite.com/post/1413616213.html</id>
    <published>2019-02-19T02:01:53.000Z</published>
    <updated>2019-02-20T15:07:06.278Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。webpack是前端目前最主流的javascript打包工具，在它的帮助下，开发者可以轻松地实现加密代码、多平台兼容。而最重要的是，它为前端工程化提供了最好支持。vue、react等大型项目的脚手架都是利用 webpack 搭建。</p><h2 id="功能介绍"><a href="#功能介绍" class="headerlink" title="功能介绍"></a>功能介绍</h2><ol><li><a href="https://godbmw.com/passages/2018-07-30-webpack-pack-js/" target="_blank" rel="noopener"><font color="blue">编写<strong>webpack.config.js</strong>，打包基本的js文件</font></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">const path = require(&quot;path&quot;);</span><br><span class="line"></span><br><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: &quot;./app.js&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    publicPath: __dirname + &quot;/dist/&quot;, // js引用路径或者CDN地址,换句话说就是js文件内部引用其他文件的路径。</span><br><span class="line">    path: path.resolve(__dirname, &quot;dist&quot;), // 打包文件的输出目录</span><br><span class="line">    filename: &quot;bundle.js&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><a href="https://godbmw.com/passages/2018-07-31-webpack-compile-es6/" target="_blank" rel="noopener"><font color="blue">webpack可以编译ES6，通过<strong>babel-loader</strong>把ES6转化成浏览器支持的js文件，通过<strong>babel-polyfill</strong>可以添加浏览器不支持的ES6的方法和函数，比如<code>new Set()</code></font></a> ，启动babel配置如下：<ul><li><strong>.babelrc文件</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">  &quot;presets&quot;: [</span><br><span class="line">    [</span><br><span class="line">      &quot;env&quot;,</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;targets&quot;: &#123;</span><br><span class="line">          &quot;browsers&quot;: [&quot;last 2 versions&quot;]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ],</span><br><span class="line">  &quot;plugins&quot;: [&quot;transform-runtime&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>webpack.config.js配置<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: &quot;./app.js&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: &quot;bundle.js&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.js$/,</span><br><span class="line">        exclude: /(node_modules)/,</span><br><span class="line">        use: &#123;</span><br><span class="line">          loader: &quot;babel-loader&quot; </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>使用babel-polyfill，它需要在我们项目的入口文件中被引入，或者在webpack.config.js中配置。这里我们采用第一种方法编写app.js:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> import &quot;babel-polyfill&quot;;</span><br><span class="line">let func = () =&gt; &#123;&#125;;</span><br><span class="line">const NUM = 45;</span><br><span class="line">let arr = [1, 2, 4];</span><br><span class="line">let arrB = arr.map(item =&gt; item * 2);</span><br><span class="line"></span><br><span class="line">console.log(arrB.includes(8));</span><br><span class="line">console.log(&quot;new Set(arrB) is &quot;, new Set(arrB));</span><br></pre></td></tr></table></figure></li></ul></li><li><a href="https://godbmw.com/passages/2018-08-06-webpack-mutiple-pages/" target="_blank" rel="noopener"><font color="blue">可以通过<strong>optimization.splitChunks</strong>来提取公共代码。webpack3.0以前提取使用的是CommonsChunkPlugin插件。</font></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  // 多页面应用</span><br><span class="line">  entry: &#123;</span><br><span class="line">    pageA: &quot;./src/pageA.js&quot;,</span><br><span class="line">    pageB: &quot;./src/pageB.js&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: path.resolve(__dirname, &quot;dist&quot;),</span><br><span class="line">    filename: &quot;[name].bundle.js&quot;,</span><br><span class="line">    chunkFilename: &quot;[name].chunk.js&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  optimization: &#123;</span><br><span class="line">    splitChunks: &#123;</span><br><span class="line">      cacheGroups: &#123;</span><br><span class="line">        // 注意: priority属性</span><br><span class="line">        // 其次: 打包业务中公共代码</span><br><span class="line">        common: &#123;</span><br><span class="line">          name: &quot;common&quot;,</span><br><span class="line">          chunks: &quot;all&quot;,</span><br><span class="line">          minSize: 1,</span><br><span class="line">          priority: 0</span><br><span class="line">        &#125;,</span><br><span class="line">        // 首先: 打包node_modules中的文件</span><br><span class="line">        vendor: &#123;</span><br><span class="line">          name: &quot;vendor&quot;,</span><br><span class="line">          test: /[\\/]node_modules[\\/]/,</span><br><span class="line">          chunks: &quot;all&quot;,</span><br><span class="line">          priority: 10</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><a href="https://godbmw.com/passages/2018-08-08-webpack-spa-split-lazy/" target="_blank" rel="noopener"><font color="blue">通过<strong>import</strong>或者<strong>require.ensure()</strong>实现代码的分割了懒加载</font></a><ul><li>import(): 引入并且自动执行相关 js 代码</li><li>require.ensure(): 引入但需要手动执行相关 js 代码</li></ul></li><li><a href="https://godbmw.com/passages/2018-08-17-webpack-css/" target="_blank" rel="noopener"><font color="blue">通过css-loader、file-loader和style-loader来处理</font></a><ul><li>css-loader: 加载.css文件</li><li>style-loade: 使用<code>&lt;style&gt;</code>将css-loader内部样式注入到我们的HTML页面，我们可以通过style-loader提供的<code>use()</code>和<code>unuse()</code>两种方法来动态加载和卸载css样式；通过style-loader增加<code>options.tranform</code>属性在加载css样式前，更改css.</li><li>url-loader: url-loader可以将图片转为base64字符串，能更快的加载图片,针对小图片</li><li>file-loader: 一旦图片过大，就需要使用file-loader的加载本地图片，故url-loader可以设置图片超过多少字节时，使用file-loader加载图片。</li></ul></li><li><a href="https://godbmw.com/passages/2018-08-18-webpack-scss/" target="_blank" rel="noopener"><font color="blue">通过node-sass、sass-loader加载器来处理scss</font></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: /\.scss$/,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &quot;style-loader&quot; // 将 JS 字符串生成为 style 节点</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &quot;css-loader&quot; // 将 CSS 转化成 CommonJS 模块</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: &quot;sass-loader&quot; // 将 Sass 编译成 CSS</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><a href="https://godbmw.com/passages/2018-08-28-webpack-scss-lazy/" target="_blank" rel="noopener"><font color="blue">使用extract-text-webpack-plugin插件实现实现 SCSS 懒加载</font></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">   rules: [</span><br><span class="line">     &#123;</span><br><span class="line">       test: /\.scss$/,</span><br><span class="line">       use: ExtractTextPlugin.extract(&#123;</span><br><span class="line">         // 注意 1</span><br><span class="line">         fallback: &#123;</span><br><span class="line">           loader: &quot;style-loader&quot;</span><br><span class="line">         &#125;,</span><br><span class="line">         use: [</span><br><span class="line">           &#123;</span><br><span class="line">             loader: &quot;css-loader&quot;,</span><br><span class="line">             options: &#123;</span><br><span class="line">               minimize: true</span><br><span class="line">             &#125;</span><br><span class="line">           &#125;,</span><br><span class="line">           &#123;</span><br><span class="line">             loader: &quot;sass-loader&quot;</span><br><span class="line">           &#125;</span><br><span class="line">         ]</span><br><span class="line">       &#125;)</span><br><span class="line">     &#125;</span><br><span class="line">   ]</span><br><span class="line"> &#125;,</span><br><span class="line"> plugins: [</span><br><span class="line">   new ExtractTextPlugin(&#123;</span><br><span class="line">     filename: &quot;[name].min.css&quot;,</span><br><span class="line">     allChunks: false // 注意 2</span><br><span class="line">   &#125;)</span><br><span class="line"> ]</span><br></pre></td></tr></table></figure>common.scss为懒加载的文件，此时需要在项目app.js入口中引入<code>style-loader/lib/addStyles</code>和<code>css-loader/lib/css-base</code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> /**webpack4: 针对scss的懒加载, 需要以下代码 */</span><br><span class="line">import &quot;style-loader/lib/addStyles&quot;;</span><br><span class="line">import &quot;css-loader/lib/css-base&quot;;</span><br><span class="line">/**************************************** */</span><br><span class="line"></span><br><span class="line">import &quot;./scss/base.scss&quot;;</span><br><span class="line"></span><br><span class="line">var loaded = false;</span><br><span class="line">window.addEventListener(&quot;click&quot;, function() &#123;</span><br><span class="line">  if (!loaded) &#123;</span><br><span class="line">    import(/* webpackChunkName: &apos;style&apos;*/ &quot;./scss/common.scss&quot;).then(_ =&gt; &#123;</span><br><span class="line">      console.log(&quot;Change bg-color of html&quot;);</span><br><span class="line">      loaded = true;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"> </span><br></pre></td></tr></table></figure>根据我们在app.js中的webpackChunkName的配置，可以猜测，打包结果中有：style.chunk.js 文件</li><li><a href="https://godbmw.com/passages/2018-09-01-js-tree-shaking/" target="_blank" rel="noopener"><font color="blue">使用JS Tree Shaking 在项目中没有使用的代码会在打包时候丢掉。<strong>注意：JS 的 Tree Shaking 依赖的是 ES2015 的模块系统（比如：import和export），因此针对第三方JS库，需要注意他是否符合ES模板系统规范。</strong>使用时不再需要UglifyjsWebpackPlugin插件， 取而代之的是，更加方便的配置方法。只需要配置mode为”production”，即可显式激活 UglifyjsWebpackPlugin 插件。</font></a></li><li><a href="https://godbmw.com/passages/2018-09-02-css-tree-shaking/" target="_blank" rel="noopener"><font color="blue">通过使用PruifyCSS和glob-all第三方库来实现Css Tree Shaking</font></a></li><li><a href="https://godbmw.com/passages/2018-09-11-webpack-image/" target="_blank" rel="noopener"><font color="blue">处理图片和进行base64编码时候使用<strong>url-loader</strong>，压缩图片可以使用<strong>img-loader</strong>，<strong>postcss-loader</strong>和<strong>postcss-sprites</strong>则用来合成雪碧图，从而减少网络请求</font></a></li><li><a href="https://godbmw.com/passages/2018-10-09-webpack-chracter-file/" target="_blank" rel="noopener"><font color="blue">借助url-loader，可以识别并且处理eot、woff等结尾的字体文件。同时，根据字体文件大小，可以灵活配置是否进行base64编码</font></a></li><li><a href="https://godbmw.com/passages/2018-10-09-webpack-js-pacakge/" target="_blank" rel="noopener"><font color="blue">针对第三种方法，如果没有webpack，则需要手动引入import或者require来加载文件；但是，webpack提供了<strong>alias</strong>的配置，配合<strong>webpack.ProvidePlugin</strong>这款插件，可以跳过手动入，直接使用！</font></a></li><li><a href="https://godbmw.com/passages/2018-10-17-automatic-html/" target="_blank" rel="noopener"><font color="blue">通过<strong>html-webpack-plugin</strong>插件来自动生成html</font></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      filename: &quot;index.html&quot;,</span><br><span class="line">      template: &quot;./index.html&quot;,</span><br><span class="line">      chunks: [&quot;app&quot;], // entry中的app入口才会被打包</span><br><span class="line">      minify: &#123;</span><br><span class="line">        // 压缩选项</span><br><span class="line">        collapseWhitespace: true</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br></pre></td></tr></table></figure></li><li><a href="https://godbmw.com/passages/2018-10-18-webpack-clean-and-watch-mode/" target="_blank" rel="noopener"><font color="blue"><strong>CleanWebpackPlugin</strong>，在每次打包前，自动清理/dist/目录下的文件。</font></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: &quot;./app.js&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    publicPath: __dirname + &quot;/dist/&quot;, // js引用路径或者CDN地址</span><br><span class="line">    path: path.resolve(__dirname, &quot;dist&quot;), // 打包文件的输出目录</span><br><span class="line">    filename: &quot;[name]-[hash:5].bundle.js&quot;,</span><br><span class="line">    chunkFilename: &quot;[name]-[hash:5].chunk.js&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    new HtmlWebpackPlugin(&#123;</span><br><span class="line">      filename: &quot;index.html&quot;,</span><br><span class="line">      template: &quot;./index.html&quot;,</span><br><span class="line">      chunks: [&quot;app&quot;]</span><br><span class="line">    &#125;),</span><br><span class="line">    new CleanWebpackPlugin([&quot;dist&quot;])</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><a href="https://godbmw.com/passages/2018-10-18-webpack-clean-and-watch-mode/" target="_blank" rel="noopener"><font color="blue">webpack-dev-server插件可以启动一个本地服务，可以进行热重载、路由重定向、挂代理等功能和sourcemap帮助开发进行代码调试</font></a></li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div class="note default"><p><a href="https://www.cnblogs.com/geyouneihan/p/9827295.html" target="_blank" rel="noopener">全网最贴心webpack系列教程和配套代码</a><br><a href="https://www.cnblogs.com/axl234/p/6500534.html" target="_blank" rel="noopener">Webpack中的sourcemap</a></p></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler)。当 webpack 处理
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>如何注意前端浏览器兼容性问题</title>
    <link href="http://yoursite.com/post/1118069504.html"/>
    <id>http://yoursite.com/post/1118069504.html</id>
    <published>2019-02-17T08:00:21.000Z</published>
    <updated>2019-02-17T08:00:21.899Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闲言"><a href="#闲言" class="headerlink" title="闲言"></a>闲言</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div class="note default"></div> ]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;闲言&quot;&gt;&lt;a href=&quot;#闲言&quot; class=&quot;headerlink&quot; title=&quot;闲言&quot;&gt;&lt;/a&gt;闲言&lt;/h2&gt;&lt;h2 id=&quot;参考文献&quot;&gt;&lt;a href=&quot;#参考文献&quot; class=&quot;headerlink&quot; title=&quot;参考文献&quot;&gt;&lt;/a&gt;参考文献&lt;/h
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>短/长轮询和WebSocket的优缺点</title>
    <link href="http://yoursite.com/post/1122290469.html"/>
    <id>http://yoursite.com/post/1122290469.html</id>
    <published>2019-02-16T08:24:21.000Z</published>
    <updated>2019-02-16T08:41:27.889Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闲言"><a href="#闲言" class="headerlink" title="闲言"></a>闲言</h2><h2 id="短轮询"><a href="#短轮询" class="headerlink" title="短轮询"></a>短轮询</h2><p><strong>定义：</strong>其实就是普通的轮询。指在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP request，然后由服务器返回最新的数据给客户端的浏览器。</p><p><strong>应用场景：</strong>传统的web通信模式。后台处理数据，需要一定时间，前端想要知道后端的处理结果，就要不定时的向后端发出请求以获得最新情况。</p><p><strong>优点：</strong>前后端程序编写比较容易。</p><p><strong>缺点：</strong>请求中有大半是无用，难于维护，浪费带宽和服务器资源；响应的结果没有顺序（因为是异步请求，当发送的请求没有返回结果的时候，后面的请求又被发送。而此时如果后面的请求比前面的请 求要先返回结果，那么当前面的请求返回结果数据时已经是过时无效的数据了）。</p><p><strong>实例：</strong>适于小型应用。</p><h2 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h2><p><strong>定义：</strong>客户端向服务器发送Ajax请求，服务器接到请求后hold住连接，直到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求。</p><p><strong>优点：</strong>在无消息的情况下不会频繁的请求，耗费资源小。</p><p><strong>缺点：</strong>服务器hold连接会消耗资源，返回数据顺序无保证，难于管理维护。</p><h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p><strong>定义：</strong>Websocket是基于HTTP协议的，在和服务端建立了链接后，服务端有数据有了变化后会主动推送给前端。</p><p><strong>优点：</strong>请求响应快，不浪费资源。（传统的http请求，其并发能力都是依赖同时发起多个TCP连接访问服务器实现的(因此并发数受限于浏览器允许的并发连接数)，而websocket则允许我们在一条ws连接上同时并发多个请求，即在A请求发出后A响应还未到达，就可以继续发出B请求。由于TCP的慢启动特性（新连接速度上来是需要时间的），以及连接本身的握手损耗，都使得websocket协议的这一特性有很大的效率提升；http协议的头部太大，且每个请求携带的几百上千字节的头部大部分是重复的，websocket则因为复用长连接而没有这一问题。）</p><p><strong>缺点：</strong>主流浏览器支持的Web Socket版本不一致；服务端没有标准的API，下图是各大主流对websocket的兼容性列表。<br><img src="/post/1122290469/websocket.png"></p><p><strong>实例：</strong>实现即时通讯:如股票交易行情分析、聊天室、在线游戏等，替代轮询和长轮询</p><p><strong>解决：</strong>解决了http协议的两个问题:</p><ol><li>服务端的被动性。http协议是只有客户端询问之后才回复。解决了同步有延迟的问题</li><li>解决了服务器上消耗资源的问题</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div class="note default"><p><a href="https://blog.csdn.net/yingzizizizizizzz/article/details/83416987" target="_blank" rel="noopener">短轮询、长轮询和web socket定义及其实现</a></p></div> ]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;闲言&quot;&gt;&lt;a href=&quot;#闲言&quot; class=&quot;headerlink&quot; title=&quot;闲言&quot;&gt;&lt;/a&gt;闲言&lt;/h2&gt;&lt;h2 id=&quot;短轮询&quot;&gt;&lt;a href=&quot;#短轮询&quot; class=&quot;headerlink&quot; title=&quot;短轮询&quot;&gt;&lt;/a&gt;短轮询&lt;/h2&gt;&lt;p
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HTTP2专题一</title>
    <link href="http://yoursite.com/post/3511927546.html"/>
    <id>http://yoursite.com/post/3511927546.html</id>
    <published>2019-02-16T06:21:27.000Z</published>
    <updated>2019-02-16T06:35:43.504Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闲言"><a href="#闲言" class="headerlink" title="闲言"></a>闲言</h2><h2 id="HTTP-1-1存在的问题"><a href="#HTTP-1-1存在的问题" class="headerlink" title="HTTP/1.1存在的问题"></a>HTTP/1.1存在的问题</h2><ol><li>TCP 连接数限制</li><li>线头阻塞 (Head Of Line Blocking) 问题</li><li>Header 内容多，而且每次请求 Header 不会变化太多，没有相应的压缩传输优化方案</li><li>为了尽可能减少请求数，需要做合并文件、雪碧图、资源内联等优化工作，但是这无疑造成了单个请求内容变大延迟变高的问题，且内嵌的资源不能有效地使用缓存机制</li><li>明文传输不安全</li></ol><h2 id="HTTP2的优势"><a href="#HTTP2的优势" class="headerlink" title="HTTP2的优势"></a>HTTP2的优势</h2><ol><li>二进制分帧层 (Binary Framing Layer)</li><li>多路复用 (MultiPlexing)</li><li>服务端推送 (Server Push)</li><li>Header 压缩 (HPACK)</li><li>应用层的重置连接</li><li>请求优先级设置</li><li>流量控制</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div class="note default"><p><a href="https://www.jianshu.com/p/e57ca4fec26f" target="_blank" rel="noopener">HTTP2 详解</a></p></div> ]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;闲言&quot;&gt;&lt;a href=&quot;#闲言&quot; class=&quot;headerlink&quot; title=&quot;闲言&quot;&gt;&lt;/a&gt;闲言&lt;/h2&gt;&lt;h2 id=&quot;HTTP-1-1存在的问题&quot;&gt;&lt;a href=&quot;#HTTP-1-1存在的问题&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ES6新特性列举</title>
    <link href="http://yoursite.com/post/2244272007.html"/>
    <id>http://yoursite.com/post/2244272007.html</id>
    <published>2019-02-15T02:30:06.000Z</published>
    <updated>2019-02-15T13:36:09.247Z</updated>
    
    <content type="html"><![CDATA[<h2 id="块作用域const和let变量"><a href="#块作用域const和let变量" class="headerlink" title="块作用域const和let变量"></a>块作用域const和let变量</h2><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><h2 id="变量的结构赋值"><a href="#变量的结构赋值" class="headerlink" title="变量的结构赋值"></a>变量的结构赋值</h2><h2 id="模板字符串-variate"><a href="#模板字符串-variate" class="headerlink" title="模板字符串${variate}"></a>模板字符串<code>${variate}</code></h2><h2 id="对象字面量的简写"><a href="#对象字面量的简写" class="headerlink" title="对象字面量的简写"></a>对象字面量的简写</h2><h2 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h2><h2 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h2><h2 id="Set和Map数据结构"><a href="#Set和Map数据结构" class="headerlink" title="Set和Map数据结构"></a>Set和Map数据结构</h2><h2 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h2><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><h2 id="模块Modules"><a href="#模块Modules" class="headerlink" title="模块Modules"></a>模块Modules</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;块作用域const和let变量&quot;&gt;&lt;a href=&quot;#块作用域const和let变量&quot; class=&quot;headerlink&quot; title=&quot;块作用域const和let变量&quot;&gt;&lt;/a&gt;块作用域const和let变量&lt;/h2&gt;&lt;h2 id=&quot;箭头函数&quot;&gt;&lt;a href
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Web Worker基础教程</title>
    <link href="http://yoursite.com/post/1337014625.html"/>
    <id>http://yoursite.com/post/1337014625.html</id>
    <published>2019-02-14T06:01:08.000Z</published>
    <updated>2019-02-15T13:36:09.248Z</updated>
    
    <content type="html"><![CDATA[<div class="note default"><p><a href="http://www.ruanyifeng.com/blog/2018/07/web-worker.html" target="_blank" rel="noopener">Web Worker 使用教程</a></p></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;note default&quot;&gt;&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2018/07/web-worker.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Web Worker 使用教程
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>js加载方式defer和async的区别与作用</title>
    <link href="http://yoursite.com/post/3350320627.html"/>
    <id>http://yoursite.com/post/3350320627.html</id>
    <published>2019-02-13T05:21:28.000Z</published>
    <updated>2019-02-15T13:36:09.248Z</updated>
    
    <content type="html"><![CDATA[<div class="note default"><p><a href="https://segmentfault.com/q/1010000000640869" target="_blank" rel="noopener">defer和async的区别</a></p></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;note default&quot;&gt;&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/q/1010000000640869&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;defer和async的区别&lt;/a&gt;&lt;/p&gt;&lt;/di
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>如何进行前端网页性能优化</title>
    <link href="http://yoursite.com/post/3048684187.html"/>
    <id>http://yoursite.com/post/3048684187.html</id>
    <published>2019-01-31T15:25:00.000Z</published>
    <updated>2019-02-15T13:36:09.248Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闲言"><a href="#闲言" class="headerlink" title="闲言"></a>闲言</h2><p>好的用户体验对于任何一个Web App都是一个非常重要的方面，想要拥有一个好的用户体验，网页的性能优化是必不可少的环节；特别是针对项目比较大、并发性比较高或者页面结构和业务逻辑比较复杂的应用，性能优化在其中体现出至关重要的一部分。下面主要针对http1.1协议来讲解一下如何让一个Web App尽可能的做到性能的极致优化。由于本人知识有限，如有描述错误，请各位同学留言指正。</p><h2 id="http请求和加载的优化"><a href="#http请求和加载的优化" class="headerlink" title="http请求和加载的优化"></a>http请求和加载的优化</h2><h3 id="一-减少http请求数量"><a href="#一-减少http请求数量" class="headerlink" title="一. 减少http请求数量"></a>一. 减少http请求数量</h3><p>在http1.1中，浏览器针对同一域名下的并发请求数量是一定的，换句话说同一域名浏览器在同一时间加载的资源（css、js或者是图片等）是一定的，一般4到5个，不同的浏览器稍有差异。因此优化目标可以分为以下两个方面：</p><ol><li>提高浏览器的并发请求所需资源的数量</li><li>合并资源，浏览器的每次请求可以获取更多的有用资源<br>因此我们可以针对以上两个方面进行优化。</li></ol><h4 id="1-适当的合并js、css和图片"><a href="#1-适当的合并js、css和图片" class="headerlink" title="1. 适当的合并js、css和图片"></a>1. 适当的合并js、css和图片</h4><p>可以使用webpack等打包工具把不经常修改的文件合并在一起。这样的话不仅可以减少请求数量，也可以很好的利用了http的缓存。</p><h4 id="2-适当的使用CSS-sprite也叫作CSS精灵"><a href="#2-适当的使用CSS-sprite也叫作CSS精灵" class="headerlink" title="2. 适当的使用CSS sprite也叫作CSS精灵"></a>2. 适当的使用CSS sprite也叫作CSS精灵</h4><p>通过使用图片合成工具把需要的各种小图标合并成一张大图标，再通过css的<code>background-position</code>来定位所需要的图片</p><h4 id="3-针对小图片也可以使用Data-RUL协议，这样图片被转换成base64编码的字符串形式-嵌入到了html中，这样在加载html时候图片资源也跟着html资源一起加载进来，减少了http请求数量；但是这样做的坏处是："><a href="#3-针对小图片也可以使用Data-RUL协议，这样图片被转换成base64编码的字符串形式-嵌入到了html中，这样在加载html时候图片资源也跟着html资源一起加载进来，减少了http请求数量；但是这样做的坏处是：" class="headerlink" title="3. 针对小图片也可以使用Data RUL协议，这样图片被转换成base64编码的字符串形式,嵌入到了html中，这样在加载html时候图片资源也跟着html资源一起加载进来，减少了http请求数量；但是这样做的坏处是："></a>3. 针对小图片也可以使用<a href="http://www.webhek.com/post/data-url.html" target="_blank" rel="noopener">Data RUL协议</a>，这样图片被转换成base64编码的字符串形式,嵌入到了html中，这样在加载html时候图片资源也跟着html资源一起加载进来，减少了http请求数量；但是这样做的坏处是：</h4><ol><li>Base64编码的数据体积通常是原数据的体积4/3，也就是Data URL形式的图片会比二进制格式的图片体积大1/3。</li><li>Data URL形式的图片不会被浏览器缓存，这意味着每次访问这样页面时都被下载一次。这是一个使用效率方面的问题——尤其当这个图片被整个网站大量使用的时候。</li></ol><div class="note primary"><p>如果想使用缓存，可以将Data URL形式的图片存储在CSS样式表中，而所有浏览器都会积极的缓存CSS文件来提高页面加载效率。具体操作可以参考<a href="http://www.webhek.com/post/data-url.html" target="_blank" rel="noopener">Data URL和图片</a></p></div><h4 id="4-可以把服务器资源放在不同的域名下，因为浏览器只会限制同一域名的请求并发数量，这样分别把不同的静态资源放入到不同的域名下，从而提高请求资源的并发数量。原理可以了解http请求头host的作用。"><a href="#4-可以把服务器资源放在不同的域名下，因为浏览器只会限制同一域名的请求并发数量，这样分别把不同的静态资源放入到不同的域名下，从而提高请求资源的并发数量。原理可以了解http请求头host的作用。" class="headerlink" title="4. 可以把服务器资源放在不同的域名下，因为浏览器只会限制同一域名的请求并发数量，这样分别把不同的静态资源放入到不同的域名下，从而提高请求资源的并发数量。原理可以了解http请求头host的作用。"></a>4. 可以把服务器资源放在不同的域名下，因为浏览器只会限制同一域名的请求并发数量，这样分别把不同的静态资源放入到不同的域名下，从而提高请求资源的并发数量。原理可以了解http请求头host的作用。</h4><h4 id="5-懒加载和预加载"><a href="#5-懒加载和预加载" class="headerlink" title="5. 懒加载和预加载"></a>5. 懒加载和预加载</h4><ul><li>懒加载：图片进入可视区域之后请求资源，对于电商，页面很长的场景，减少无效的资源加载（单页应用，观看的时候才去加载）。实现方法参考：图片的src的地址被改变的时候被加载。监听滑动的事件，当图片进入可视区域的时候才去加载。</li><li>预加载：与懒加载相反，预加载静态资源使用之前提前进行请求。直接从缓存中进行加载，不需要发送请求。</li></ul><h3 id="二-避免阻塞dom渲染"><a href="#二-避免阻塞dom渲染" class="headerlink" title="二. 避免阻塞dom渲染"></a>二. 避免阻塞dom渲染</h3><ol><li>CSS的加载不会阻塞DOM树的解析，但是会阻塞DOM树的渲染</li><li>CSS的加载会阻塞后面js语句的执行</li><li>js的加载和执行会阻塞DOM树的解析</li></ol><p>针对以上情况，优化点如下：</p><ol><li>css样式表置顶</li><li>用link代替import</li><li>js脚本置顶，放到body标签后面</li><li>合理使用js的异步加载能力</li></ol><h3 id="三-http缓存优化"><a href="#三-http缓存优化" class="headerlink" title="三. http缓存优化"></a>三. http缓存优化</h3><h3 id="四-通过Media-Query按需加载"><a href="#四-通过Media-Query按需加载" class="headerlink" title="四. 通过Media Query按需加载"></a>四. 通过Media Query按需加载</h3><h3 id="五-减少传输文件的大小"><a href="#五-减少传输文件的大小" class="headerlink" title="五. 减少传输文件的大小"></a>五. 减少传输文件的大小</h3><img src="/post/3048684187/main.jpeg"><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div class="note default"><p><a href="https://www.jianshu.com/p/fe32ef31deed" target="_blank" rel="noopener">前端性能优化总结</a><br>    <a href="https://www.cnblogs.com/dreamowneryong/p/4773201.html" target="_blank" rel="noopener">base64图片解析</a><br>     <a href="https://www.jianshu.com/p/10ca32480c1e" target="_blank" rel="noopener">base64和css sprites的区别</a><br>     <a href="https://harttle.land/2016/05/18/async-javascript-loading.html" target="_blank" rel="noopener">异步加载脚本</a><br>     <a href="https://juejin.im/post/59d489156fb9a00a571d6509" target="_blank" rel="noopener">浏览器渲染过程与性能优化</a><br>     <a href="https://blog.seosiwei.com/detail/33" target="_blank" rel="noopener">如何做到网页性能的极致优化</a></p></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;闲言&quot;&gt;&lt;a href=&quot;#闲言&quot; class=&quot;headerlink&quot; title=&quot;闲言&quot;&gt;&lt;/a&gt;闲言&lt;/h2&gt;&lt;p&gt;好的用户体验对于任何一个Web App都是一个非常重要的方面，想要拥有一个好的用户体验，网页的性能优化是必不可少的环节；特别是针对项目比较大
      
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>html页面渲染过程详解</title>
    <link href="http://yoursite.com/post/3918118019.html"/>
    <id>http://yoursite.com/post/3918118019.html</id>
    <published>2019-01-28T14:11:47.000Z</published>
    <updated>2019-01-31T15:23:49.786Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闲言"><a href="#闲言" class="headerlink" title="闲言"></a>闲言</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div class="note default"><p><a href="https://www.cnblogs.com/dojo-lzz/p/3983335.html" target="_blank" rel="noopener">HTML渲染过程详解</a><br><a href="https://www.cnblogs.com/chenjg/p/10099886.html" target="_blank" rel="noopener">你真的了解回流和重绘吗</a><br><a href="https://juejin.im/post/59d489156fb9a00a571d6509" target="_blank" rel="noopener">浏览器渲染过程与性能优化</a><br><a href="https://blog.csdn.net/cristina_song/article/details/77512534" target="_blank" rel="noopener">js执行会阻塞DOM树的解析和渲染，那么css加载会阻塞DOM树的解析和渲染吗</a></p></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;闲言&quot;&gt;&lt;a href=&quot;#闲言&quot; class=&quot;headerlink&quot; title=&quot;闲言&quot;&gt;&lt;/a&gt;闲言&lt;/h2&gt;&lt;h2 id=&quot;参考文献&quot;&gt;&lt;a href=&quot;#参考文献&quot; class=&quot;headerlink&quot; title=&quot;参考文献&quot;&gt;&lt;/a&gt;参考文献&lt;/h
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ES6的Rest参数和对象展开运算符</title>
    <link href="http://yoursite.com/post/3368437986.html"/>
    <id>http://yoursite.com/post/3368437986.html</id>
    <published>2019-01-26T07:16:31.000Z</published>
    <updated>2019-01-26T09:17:06.987Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闲言"><a href="#闲言" class="headerlink" title="闲言"></a>闲言</h2><p>ES6是ECMAScript标准十余年来变动最大的一个版本，其中添加了许多新的语法特性，既有大家耳熟能详的Promise，也有闻所未闻的Proxy代理和Reflection反射；既有可以通过转译器（Transpiler）等方式在旧版本浏览器中实现兼容的let、const、不定参数、展开运算符等功能，亦有无论如何都无法实现向前兼容的尾调用优化。深入理解ES6的特性对于所有JavaScript开发者而言至关重要，在可预见的未来，ES6中引入的语言特性会成为JavaScript应用程序的主流特性。因此本文探讨ES6中的两个重要且常用的特性，它们是Rest和对象展开运算符。由于本人知识有限，如有描述错误请留言指正。</p><h2 id="Rest参数"><a href="#Rest参数" class="headerlink" title="Rest参数"></a>Rest参数</h2><p>Rest参数接受函数的多余参数，组成一个数组，放在形参的最后；形式为<code>...变量名</code>。<strong>特别注意Rest参数只会出现在函数的形参中，否则都是对象的扩展</strong>，具体实例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function add(a, b, ...params) &#123;</span><br><span class="line">    console.log(params); //[ 3, 4, 5 ]</span><br><span class="line">    console.log(arguments); // &#123; &apos;0&apos;: 1, &apos;1&apos;: 2, &apos;2&apos;: 3, &apos;3&apos;: 4, &apos;4&apos;: 5 &#125;</span><br><span class="line">    let arguArray = Array.prototype.slice.apply(arguments);</span><br><span class="line">    // let arguArray = Array.from(arguments);</span><br><span class="line">    console.log(arguArray); //[ 1, 2, 3, 4, 5 ]</span><br><span class="line">    console.log(Array.isArray(arguArray)); // true</span><br><span class="line">    console.log(Array.isArray(params)); // true</span><br><span class="line">    console.log(Array.isArray(arguments)) // false</span><br><span class="line">&#125;</span><br><span class="line">add(1, 2, 3, 4, 5);</span><br></pre></td></tr></table></figure><br>上面实例代码可以看出：</p><ul><li>Rest参数只包括那些没有给出名称的参数，arguments包含所有参数。</li><li>arguments对象不是真正的数组，因此没有数组的一些方法特性；而Rest 参数是数组实例，因此拥有数组所有的方法特性。其实arguments是一个类似数组的伪数组（具有length属性，并且按照索引方式存储数据，但是不具有push()、pop()等数组方法，形式可以看上面代码3行），可以通过上面代码中4行或者是5行转换成真正的数组。<br>如果把Rest参数不放在函数形参的最后会怎么样呢？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function add(a, ...params, b) &#123;&#125;</span><br><span class="line">add(1, 2, 3, 4, 5);</span><br></pre></td></tr></table></figure>运行结果报错：<div class="note danger"><p>SyntaxError: Rest parameter must be last formal parameter</p></div><div class="note primary"><p>结果表明Rest参数之后不能再有其他参数，换句话说它必须是形参的最后一个参数！！！</p></div></li></ul><h3 id="Rest扩展知识"><a href="#Rest扩展知识" class="headerlink" title="Rest扩展知识"></a>Rest扩展知识</h3><p>Rest参数可以被结构解析(通俗一点，将rest参数的数据解析后一一对应)不要忘记参数用[]括起来，因为它是数组，实例代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function add(a, b, ...[c, d, e]) &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">    console.log(b);</span><br><span class="line">    console.log(c);</span><br><span class="line">    console.log(d);</span><br><span class="line">    console.log(e);</span><br><span class="line">&#125;</span><br><span class="line">add(1, 2, 3, 4, 5);</span><br><span class="line">add(1, 2, 3);</span><br><span class="line">add(1,2,3,4,5,6);</span><br></pre></td></tr></table></figure><br>结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">undefined</span><br><span class="line">undefined</span><br></pre></td></tr></table></figure><br>结果表明，结构解析中如果参数传递不够，对应的变量为undefined。</p><h2 id="展开运算符"><a href="#展开运算符" class="headerlink" title="展开运算符"></a>展开运算符</h2><p>扩展运算符（spread）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。展开运算符的应用场景非常之多。</p><ul><li><strong>可以很方便的实现对象的合并</strong>。比如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let object1 = &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let object2 = &#123;</span><br><span class="line">    a: 2,</span><br><span class="line">    c: 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let object3 = &#123;...object1, ...object2 &#125;;</span><br><span class="line">let object4 = &#123;...object2, a: 3, d: 4 &#125;;</span><br><span class="line">console.log(&apos;object3：&apos;, object3);</span><br><span class="line">console.log(&apos;object4：&apos;, object4);</span><br></pre></td></tr></table></figure>结果如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">object3： &#123; a: 2, b: 2, c: 3 &#125;</span><br><span class="line">object4： &#123; a: 3, c: 3, d: 4 &#125;</span><br></pre></td></tr></table></figure></li><li><strong>合并数组</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr1 = [1, 2, 3];</span><br><span class="line">let arr2 = [4, 5];</span><br><span class="line">arr1.push(...arr2);</span><br><span class="line">console.log(arr1);</span><br></pre></td></tr></table></figure>结果如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ 1, 2, 3, 4, 5 ]</span><br></pre></td></tr></table></figure>如果你想要整合两个数组，并且想把某个数组放在另一个数组的任意特定位置上，你可以这么做：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = [&apos;two&apos;, &apos;three&apos;];</span><br><span class="line">var arr2 = [&apos;one&apos;, ...arr1, &apos;four&apos;, &apos;five&apos;];</span><br><span class="line"></span><br><span class="line">// [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;]</span><br></pre></td></tr></table></figure></li><li><strong>拷贝数组</strong><br>之前我们拷贝数组可以通过slice和concat等方法，有了对象扩展运算符我们也可以这样：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3];</span><br><span class="line">var arr2 = [...arr];</span><br><span class="line">arr2.push(4)</span><br><span class="line">console.log(&apos;arr2&apos;, arr2);</span><br><span class="line">console.log(&apos;arr&apos;, arr);</span><br></pre></td></tr></table></figure>结果如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr2 [ 1, 2, 3, 4 ]</span><br><span class="line">arr [ 1, 2, 3 ]</span><br></pre></td></tr></table></figure></li><li><strong>将arguments或者NodeList等伪数组转换为真正的数组</strong>。像这样：<br><code>[...arguments]</code>和<code>[...document.querySelectorAll(&#39;div&#39;)]</code></li></ul><p>还有其它一些应用不一一列举。需要注意的是：<br><div class="note primary"><p>展开运算符将数组“展开”成为不同的参数，所以任何可接收任意数量的参数的函数，都能够使用展开运算符来传参。比如：<code>Math.min(...[1,2,3]);</code></p></div></p><h2 id="Rest参数和对象展开运算符的关系"><a href="#Rest参数和对象展开运算符的关系" class="headerlink" title="Rest参数和对象展开运算符的关系"></a>Rest参数和对象展开运算符的关系</h2><ul><li>对象展开运算符就好比Rest参数的逆运算。</li><li>Rest参数是存在于形参当中，而对象展开运算符是不存在形参中的。</li><li>Rest参数作用于把传入的参数转化成数组，而对象扩展运算符是把不管是数组还是非数组对象扩展成一个个值。</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div class="note default"><p><a href="https://www.jianshu.com/p/50bcb376a419" target="_blank" rel="noopener">ES6 Rest参数</a><br><a href="https://www.jianshu.com/p/c5230c11781b" target="_blank" rel="noopener">ES6展开运算符的6种妙用</a></p></div> ]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;闲言&quot;&gt;&lt;a href=&quot;#闲言&quot; class=&quot;headerlink&quot; title=&quot;闲言&quot;&gt;&lt;/a&gt;闲言&lt;/h2&gt;&lt;p&gt;ES6是ECMAScript标准十余年来变动最大的一个版本，其中添加了许多新的语法特性，既有大家耳熟能详的Promise，也有闻所未闻的Pr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>通过css用div画出三角形</title>
    <link href="http://yoursite.com/post/2276870894.html"/>
    <id>http://yoursite.com/post/2276870894.html</id>
    <published>2019-01-19T04:41:13.000Z</published>
    <updated>2019-01-19T06:06:32.990Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闲言"><a href="#闲言" class="headerlink" title="闲言"></a>闲言</h2><p>通过css可以实现不同样式的三角形，其中的原理可以了解一下<a href="http://www.cnblogs.com/cchyao/archive/2010/07/12/1775846.html" target="_blank" rel="noopener">盒子模型</a>，闲言少叙，直接开始吧！</p><h2 id="基本入门"><a href="#基本入门" class="headerlink" title="基本入门"></a>基本入门</h2><p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Static Template&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .angel &#123;</span><br><span class="line">            display: inline-block;</span><br><span class="line">            border-width: 100px 100px 100px 100px;</span><br><span class="line">            border-color: red yellow green gray;</span><br><span class="line">            border-style: solid;</span><br><span class="line">            width: 50px;</span><br><span class="line">            height: 50px;</span><br><span class="line">            box-sizing: content-box;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;angel&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><br>效果图如下：<br><img src="/post/2276870894/1.png"><br>代码17行作用是使用标准的盒子模型，如果使用IE盒子模型（box-sizing：border-box;），就不会出现中间的空白方块，大家可以自行测试。当我们调整width和height为5px，效果图如下：<br><img src="/post/2276870894/2.png"><br>当width和height为0时，效果图如下<br><img src="/post/2276870894/3.png"><br>感觉像不像四个三角形拼接在一起，如果我们想要绿色的三角形，我们可以把其它三个边框的颜色设置成transparent,代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.angel &#123;</span><br><span class="line">            display: inline-block;</span><br><span class="line">            border-width: 100px 100px 100px 100px;</span><br><span class="line">            border-color: transparent transparent green transparent;</span><br><span class="line">            border-style: solid;</span><br><span class="line">            box-sizing: content-box;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><br>效果图如下：<br><img src="/post/2276870894/4.png"><br>但是其它边的颜色已经透明，但是所占区域还是存在的，我们可以审查一下元素，如图所示：<br><img src="/post/2276870894/5.png"><br>因此我们把上边框的border-width设置为0，得到下图：<br><img src="/post/2276870894/6.png"><br>是不是我们想要达到的效果。我们也可以设置左边或者右边的border为0，得到该三角形其中的一半（也是一个三角形），代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.angel &#123;</span><br><span class="line">            display: inline-block;</span><br><span class="line">            border-width: 0 100px 100px 0;</span><br><span class="line">            border-color: transparent transparent green transparent;</span><br><span class="line">            border-style: solid;</span><br><span class="line">            box-sizing: content-box;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><br>效果图如下：<br><img src="/post/2276870894/7.png"><br>因此通过调整border不同方向的width和color，我们就可以得到任意不同方向的三角形。</p><h2 id="实战练习"><a href="#实战练习" class="headerlink" title="实战练习"></a>实战练习</h2><h3 id="1-实现一个角度为30度的直角三角形"><a href="#1-实现一个角度为30度的直角三角形" class="headerlink" title="1. 实现一个角度为30度的直角三角形"></a>1. 实现一个角度为30度的直角三角形</h3><p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.angel &#123;</span><br><span class="line">            display: inline-block;</span><br><span class="line">            border-width: 0px 100px 173px 0px;</span><br><span class="line">            border-color: transparent transparent green transparent;</span><br><span class="line">            border-style: solid;</span><br><span class="line">            box-sizing: content-box;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><br>如图所示：<br><img src="/post/2276870894/8.png"></p><h3 id="2-实现一个带有边框的三角形"><a href="#2-实现一个带有边框的三角形" class="headerlink" title="2. 实现一个带有边框的三角形"></a>2. 实现一个带有边框的三角形</h3><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div class="note default"><p><a href="http://www.cnblogs.com/v-weiwang/p/5057588.html" target="_blank" rel="noopener">css如何将div画成三角形</a></p></div> ]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;闲言&quot;&gt;&lt;a href=&quot;#闲言&quot; class=&quot;headerlink&quot; title=&quot;闲言&quot;&gt;&lt;/a&gt;闲言&lt;/h2&gt;&lt;p&gt;通过css可以实现不同样式的三角形，其中的原理可以了解一下&lt;a href=&quot;http://www.cnblogs.com/cchyao/ar
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Angualr介绍</title>
    <link href="http://yoursite.com/post/2552726188.html"/>
    <id>http://yoursite.com/post/2552726188.html</id>
    <published>2019-01-19T03:16:59.000Z</published>
    <updated>2019-01-19T04:33:30.023Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闲言"><a href="#闲言" class="headerlink" title="闲言"></a>闲言</h2><ol><li>编译的时候可以代码检查bug，从而减少运行时的bug</li><li>IDE更好的代码提示，和更快的性能</li><li>angular核心就是组件，装饰器模式</li><li>angular组件非常容易编写，装饰器模式更加人性化</li><li>服务器端渲染，可以增强性能也可以提高seo优化</li><li></li></ol><h2 id="Angular-CLI"><a href="#Angular-CLI" class="headerlink" title="Angular CLI"></a>Angular CLI</h2><h2 id="与React对比"><a href="#与React对比" class="headerlink" title="与React对比"></a>与React对比</h2><ol><li>React虚拟dom，先更新虚拟dom，在更新实际dom</li><li>Angular 新的变更检测算法</li><li>Angular 服务器端渲染，服务器预渲染首页加载优化，是seo引擎优化</li><li>单页缺陷是对seo很大缺陷</li></ol><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><p>不是完整的框架，第三方组件没有Angualr多</p><h2 id="VUE"><a href="#VUE" class="headerlink" title="VUE"></a>VUE</h2><p>简单<br>学习和使用不高，中文文档<br>cli更灵活<br>尺寸小，十几k<br>个人主导的，但是angular是google开发的，用的还是微软的typeScript<br>只关注web框架</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div class="note default"></div> ]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;闲言&quot;&gt;&lt;a href=&quot;#闲言&quot; class=&quot;headerlink&quot; title=&quot;闲言&quot;&gt;&lt;/a&gt;闲言&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;编译的时候可以代码检查bug，从而减少运行时的bug&lt;/li&gt;
&lt;li&gt;IDE更好的代码提示，和更快的性能&lt;/li&gt;
&lt;li&gt;a
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>http请求头origin和referer区别</title>
    <link href="http://yoursite.com/post/2885576345.html"/>
    <id>http://yoursite.com/post/2885576345.html</id>
    <published>2019-01-17T07:37:00.000Z</published>
    <updated>2019-01-19T03:07:08.172Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闲言"><a href="#闲言" class="headerlink" title="闲言"></a>闲言</h2><p>之前在做web项目中，每次使用chrome调试前端的时候经常会看到请求头header中经常会包含Referer和Origin字段，并且它俩的值有时长的还差不多，网上一查，它俩确实很相似，今天乘着闲暇的机会，整理一下它们各自的作用和区别。本人知识有限，如有错误欢迎留言指正。</p><h2 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h2><p>Referer其实应该是英文单词Referrer，不过拼错的人太多了，所以编写标准的人也就将错就错了。它是客户端请求头的一部分，当浏览器向web服务器发送请求的时候，<strong>一般会带上Referer</strong><font color="red">（不论是get请求还是post请求）</font>，告诉服务器我是从哪个页面链接过来的。比如说有个网址A：<code>https://mbd.baidu.com/newspage/data/landingsuper?context=%7B%22nid%22%3A%22news_1763945507961089360%22%7D&amp;n_type=0&amp;p_from=1</code>，A页面有个链接链接到了网站B：<code>https://mbd.baidu.com/newspage/data/landingsuper?context=%7B%22nid%22%3A%22news_9452777449866334360%22%7D&amp;n_type=0&amp;p_from=4</code>，如果你点击A页面的链接请求B页面，那么这时请求B页面的请求头中Referer就是A的网址：<code>https://mbd.baidu.com/newspage/data/landingsuper?context=%7B%22nid%22%3A%22news_9452777449866334360%22%7D&amp;n_type=0&amp;p_from=1</code>，你可以在B页面中调用浏览器的调试工具查看请求头验证一下。刚才说了<strong>一般会带上Referer</strong>，那么什么情况下不会带上呢？根据自己的验证和别人的分享，我总结出Referer的存在需要具备两个要素：</p><ol><li>浏览器（客户端）请求（服务器端请求的情况下，是不存在referer的，但是可以伪造header）</li><li>存在前导页，就是你的页面是从哪个页面链接过来的</li></ol><p>因此根据这两个要素，可以大致列举出不会带上Referer的几种情况如下：</p><ul><li>在浏览器内直接敲URL（没有前导页）</li><li>windows桌面上的超链接图标（原因同上）</li><li>浏览器内书签（同上）</li><li>第三方软件（如Word，Excel等）内容中的链接（不是浏览器）</li><li>使用JavaScript的Location.href或者是Location.replace()</li><li>SSL认证网站跳入(网站部署SSL证书后，可以通过在服务器设置301重定向让HTTP自动跳转到HTTPS，也可以通过设置JS跳转实现HTTP自动跳转到HTTPS）<br>然而在以下两种情况下，Referer不会被发送：</li></ul><ol><li>来源页面采用的协议为表示本地文件的 “file” 或者 “data” URI</li><li>当前请求页面采用的是非安全协议，而来源页面采用的是安全协议（HTTPS）</li></ol><div class="note danger"><p>Referer 首部可能暴露用户的浏览历史，涉及到用户的隐私问题。</p></div><h2 id="Referer的作用"><a href="#Referer的作用" class="headerlink" title="Referer的作用"></a>Referer的作用</h2><ul><li>统计访问这个页面从哪个前导页链接过来的次数</li><li>防止盗链，盗链的解释，请参考<a href="https://baike.baidu.com/item/%E7%9B%97%E9%93%BE?fr=aladdin" target="_blank" rel="noopener">百度百科</a>，当一个请求到达服务器，特别是CDN服务器的时候，CDN服务器可以根据该字段来判断来源站点是否是合作伙伴，或者是可信任的，然后再决定是否将资源返回给它</li><li>防止恶意请求，比如说只允许外部网站访问我的静态资源，对于动态资源，不允许从外部网站访问，这样在一定程度上可以避免CSRF攻击。当然了，依赖客户端的请求是很不可靠的，因为这个可以轻轻松松伪造。</li></ul><h2 id="Origin"><a href="#Origin" class="headerlink" title="Origin"></a>Origin</h2><p>请求首部字段 Origin 指示了请求来自于哪个站点。<strong>该字段仅指示服务器名称，并不包含任何路径信息</strong>。该首部<strong>只用于 CORS 请求或者 POST 请求</strong>。除了不包含路径信息，该字段与 Referer 首部字段相似。表现形式如下：<br><div class="note primary"><p>Origin: “”<br>Origin: <scheme> “://“ <host> [ “:” <port> ]</port></host></scheme></p></div><br>有时候将该字段的值置空是有用的，例如，资源由一个 data URL 指定</p><h2 id="Origin的作用"><a href="#Origin的作用" class="headerlink" title="Origin的作用"></a>Origin的作用</h2><p>从上面可以看出，其实referrer所能满足的要求，origin全部都能达到，事实上，origin的提出，本身就是在HTML5中跨域操作所引入的。 其具体流程是，当一个链接或者XMLHttpRequest去请求跨域操作，浏览器事实上的确向目标服务器发起了连接请求，并且携带这origin。 当服务器返回时，浏览器将检查response中是否包Access-Control-Allow-Origin字段，当缺少这个字段时，浏览器将abort，abort的意思是不显示，不产生事件，就好像没有请求过，甚至在network区域里面都看不到。 当存在这个header时，浏览器将检查当前请求所在域是否在这个access-control-allow-origin所允许的域内，如果是，继续下去，如果不存在，abort！</p><h2 id="两者主要区别"><a href="#两者主要区别" class="headerlink" title="两者主要区别"></a>两者主要区别</h2><ul><li>Origin不包含前导页任何的路径信息，但是Referer包含了前导页的路径信息，可能会透露出用户信息或者是用户浏览历史等隐私信息，因此Origin相对比Referer安全。</li><li>Referer不论是get请求和post请求都会存在，Origin当出现CORS时get和post请求都会出现，否则只会出现在post请求中。</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div class="note default"><p><a href="https://blog.csdn.net/fishmai/article/details/52388840" target="_blank" rel="noopener">Referer详解</a><br><a href="https://blog.csdn.net/zdavb/article/details/51161130" target="_blank" rel="noopener">彻底搞清referrer和origin</a></p></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;闲言&quot;&gt;&lt;a href=&quot;#闲言&quot; class=&quot;headerlink&quot; title=&quot;闲言&quot;&gt;&lt;/a&gt;闲言&lt;/h2&gt;&lt;p&gt;之前在做web项目中，每次使用chrome调试前端的时候经常会看到请求头header中经常会包含Referer和Origin字段，并且它俩的
      
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
      <category term="header" scheme="http://yoursite.com/tags/header/"/>
    
      <category term="Origin" scheme="http://yoursite.com/tags/Origin/"/>
    
      <category term="Referer" scheme="http://yoursite.com/tags/Referer/"/>
    
  </entry>
  
  <entry>
    <title>详解http请求头host</title>
    <link href="http://yoursite.com/post/3695960831.html"/>
    <id>http://yoursite.com/post/3695960831.html</id>
    <published>2019-01-17T07:33:00.000Z</published>
    <updated>2019-01-17T15:49:38.860Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
      <category term="header" scheme="http://yoursite.com/tags/header/"/>
    
      <category term="host" scheme="http://yoursite.com/tags/host/"/>
    
  </entry>
  
  <entry>
    <title>http header详解</title>
    <link href="http://yoursite.com/post/956247918.html"/>
    <id>http://yoursite.com/post/956247918.html</id>
    <published>2019-01-16T11:57:00.000Z</published>
    <updated>2019-01-16T14:46:12.919Z</updated>
    
    <content type="html"><![CDATA[<div class="note class_name"><p><a href="https://segmentfault.com/a/1190000008900299" target="_blank" rel="noopener">HTTP 最强资料大全</a><br><a href="http://www.cnblogs.com/Joans/p/3956490.html" target="_blank" rel="noopener">HTTP Header 详解</a></p></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;note class_name&quot;&gt;&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000008900299&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HTTP 最强资料大全&lt;/a&gt;&lt;br&gt;&lt;a h
      
    
    </summary>
    
    
  </entry>
  
</feed>
