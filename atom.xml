<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>姚俊的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-02-16T08:41:27.889Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>胖胖</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>短/长轮询和WebSocket的优缺点</title>
    <link href="http://yoursite.com/post/1122290469.html"/>
    <id>http://yoursite.com/post/1122290469.html</id>
    <published>2019-02-16T08:24:21.000Z</published>
    <updated>2019-02-16T08:41:27.889Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闲言"><a href="#闲言" class="headerlink" title="闲言"></a>闲言</h2><h2 id="短轮询"><a href="#短轮询" class="headerlink" title="短轮询"></a>短轮询</h2><p><strong>定义：</strong>其实就是普通的轮询。指在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP request，然后由服务器返回最新的数据给客户端的浏览器。</p><p><strong>应用场景：</strong>传统的web通信模式。后台处理数据，需要一定时间，前端想要知道后端的处理结果，就要不定时的向后端发出请求以获得最新情况。</p><p><strong>优点：</strong>前后端程序编写比较容易。</p><p><strong>缺点：</strong>请求中有大半是无用，难于维护，浪费带宽和服务器资源；响应的结果没有顺序（因为是异步请求，当发送的请求没有返回结果的时候，后面的请求又被发送。而此时如果后面的请求比前面的请 求要先返回结果，那么当前面的请求返回结果数据时已经是过时无效的数据了）。</p><p><strong>实例：</strong>适于小型应用。</p><h2 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h2><p><strong>定义：</strong>客户端向服务器发送Ajax请求，服务器接到请求后hold住连接，直到有新消息才返回响应信息并关闭连接，客户端处理完响应信息后再向服务器发送新的请求。</p><p><strong>优点：</strong>在无消息的情况下不会频繁的请求，耗费资源小。</p><p><strong>缺点：</strong>服务器hold连接会消耗资源，返回数据顺序无保证，难于管理维护。</p><h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p><strong>定义：</strong>Websocket是基于HTTP协议的，在和服务端建立了链接后，服务端有数据有了变化后会主动推送给前端。</p><p><strong>优点：</strong>请求响应快，不浪费资源。（传统的http请求，其并发能力都是依赖同时发起多个TCP连接访问服务器实现的(因此并发数受限于浏览器允许的并发连接数)，而websocket则允许我们在一条ws连接上同时并发多个请求，即在A请求发出后A响应还未到达，就可以继续发出B请求。由于TCP的慢启动特性（新连接速度上来是需要时间的），以及连接本身的握手损耗，都使得websocket协议的这一特性有很大的效率提升；http协议的头部太大，且每个请求携带的几百上千字节的头部大部分是重复的，websocket则因为复用长连接而没有这一问题。）</p><p><strong>缺点：</strong>主流浏览器支持的Web Socket版本不一致；服务端没有标准的API，下图是各大主流对websocket的兼容性列表。<br><img src="/post/1122290469/websocket.png"></p><p><strong>实例：</strong>实现即时通讯:如股票交易行情分析、聊天室、在线游戏等，替代轮询和长轮询</p><p><strong>解决：</strong>解决了http协议的两个问题:</p><ol><li>服务端的被动性。http协议是只有客户端询问之后才回复。解决了同步有延迟的问题</li><li>解决了服务器上消耗资源的问题</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div class="note default"><p><a href="https://blog.csdn.net/yingzizizizizizzz/article/details/83416987" target="_blank" rel="noopener">短轮询、长轮询和web socket定义及其实现</a></p></div> ]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;闲言&quot;&gt;&lt;a href=&quot;#闲言&quot; class=&quot;headerlink&quot; title=&quot;闲言&quot;&gt;&lt;/a&gt;闲言&lt;/h2&gt;&lt;h2 id=&quot;短轮询&quot;&gt;&lt;a href=&quot;#短轮询&quot; class=&quot;headerlink&quot; title=&quot;短轮询&quot;&gt;&lt;/a&gt;短轮询&lt;/h2&gt;&lt;p
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HTTP2专题一</title>
    <link href="http://yoursite.com/post/3511927546.html"/>
    <id>http://yoursite.com/post/3511927546.html</id>
    <published>2019-02-16T06:21:27.000Z</published>
    <updated>2019-02-16T06:35:43.504Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闲言"><a href="#闲言" class="headerlink" title="闲言"></a>闲言</h2><h2 id="HTTP-1-1存在的问题"><a href="#HTTP-1-1存在的问题" class="headerlink" title="HTTP/1.1存在的问题"></a>HTTP/1.1存在的问题</h2><ol><li>TCP 连接数限制</li><li>线头阻塞 (Head Of Line Blocking) 问题</li><li>Header 内容多，而且每次请求 Header 不会变化太多，没有相应的压缩传输优化方案</li><li>为了尽可能减少请求数，需要做合并文件、雪碧图、资源内联等优化工作，但是这无疑造成了单个请求内容变大延迟变高的问题，且内嵌的资源不能有效地使用缓存机制</li><li>明文传输不安全</li></ol><h2 id="HTTP2的优势"><a href="#HTTP2的优势" class="headerlink" title="HTTP2的优势"></a>HTTP2的优势</h2><ol><li>二进制分帧层 (Binary Framing Layer)</li><li>多路复用 (MultiPlexing)</li><li>服务端推送 (Server Push)</li><li>Header 压缩 (HPACK)</li><li>应用层的重置连接</li><li>请求优先级设置</li><li>流量控制</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div class="note default"><p><a href="https://www.jianshu.com/p/e57ca4fec26f" target="_blank" rel="noopener">HTTP2 详解</a></p></div> ]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;闲言&quot;&gt;&lt;a href=&quot;#闲言&quot; class=&quot;headerlink&quot; title=&quot;闲言&quot;&gt;&lt;/a&gt;闲言&lt;/h2&gt;&lt;h2 id=&quot;HTTP-1-1存在的问题&quot;&gt;&lt;a href=&quot;#HTTP-1-1存在的问题&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ES6新特性列举</title>
    <link href="http://yoursite.com/post/2244272007.html"/>
    <id>http://yoursite.com/post/2244272007.html</id>
    <published>2019-02-15T02:30:06.000Z</published>
    <updated>2019-02-15T13:36:09.247Z</updated>
    
    <content type="html"><![CDATA[<h2 id="块作用域const和let变量"><a href="#块作用域const和let变量" class="headerlink" title="块作用域const和let变量"></a>块作用域const和let变量</h2><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><h2 id="变量的结构赋值"><a href="#变量的结构赋值" class="headerlink" title="变量的结构赋值"></a>变量的结构赋值</h2><h2 id="模板字符串-variate"><a href="#模板字符串-variate" class="headerlink" title="模板字符串${variate}"></a>模板字符串<code>${variate}</code></h2><h2 id="对象字面量的简写"><a href="#对象字面量的简写" class="headerlink" title="对象字面量的简写"></a>对象字面量的简写</h2><h2 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h2><h2 id="async函数"><a href="#async函数" class="headerlink" title="async函数"></a>async函数</h2><h2 id="Set和Map数据结构"><a href="#Set和Map数据结构" class="headerlink" title="Set和Map数据结构"></a>Set和Map数据结构</h2><h2 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h2><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><h2 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h2><h2 id="模块Modules"><a href="#模块Modules" class="headerlink" title="模块Modules"></a>模块Modules</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;块作用域const和let变量&quot;&gt;&lt;a href=&quot;#块作用域const和let变量&quot; class=&quot;headerlink&quot; title=&quot;块作用域const和let变量&quot;&gt;&lt;/a&gt;块作用域const和let变量&lt;/h2&gt;&lt;h2 id=&quot;箭头函数&quot;&gt;&lt;a href
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Web Worker基础教程</title>
    <link href="http://yoursite.com/post/1337014625.html"/>
    <id>http://yoursite.com/post/1337014625.html</id>
    <published>2019-02-14T06:01:08.000Z</published>
    <updated>2019-02-15T13:36:09.248Z</updated>
    
    <content type="html"><![CDATA[<div class="note default"><p><a href="http://www.ruanyifeng.com/blog/2018/07/web-worker.html" target="_blank" rel="noopener">Web Worker 使用教程</a></p></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;note default&quot;&gt;&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2018/07/web-worker.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Web Worker 使用教程
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>js加载方式defer和async的区别与作用</title>
    <link href="http://yoursite.com/post/3350320627.html"/>
    <id>http://yoursite.com/post/3350320627.html</id>
    <published>2019-02-13T05:21:28.000Z</published>
    <updated>2019-02-15T13:36:09.248Z</updated>
    
    <content type="html"><![CDATA[<div class="note default"><p><a href="https://segmentfault.com/q/1010000000640869" target="_blank" rel="noopener">defer和async的区别</a></p></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;note default&quot;&gt;&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/q/1010000000640869&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;defer和async的区别&lt;/a&gt;&lt;/p&gt;&lt;/di
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>如何进行前端网页性能优化</title>
    <link href="http://yoursite.com/post/3048684187.html"/>
    <id>http://yoursite.com/post/3048684187.html</id>
    <published>2019-01-31T15:25:00.000Z</published>
    <updated>2019-02-15T13:36:09.248Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闲言"><a href="#闲言" class="headerlink" title="闲言"></a>闲言</h2><p>好的用户体验对于任何一个Web App都是一个非常重要的方面，想要拥有一个好的用户体验，网页的性能优化是必不可少的环节；特别是针对项目比较大、并发性比较高或者页面结构和业务逻辑比较复杂的应用，性能优化在其中体现出至关重要的一部分。下面主要针对http1.1协议来讲解一下如何让一个Web App尽可能的做到性能的极致优化。由于本人知识有限，如有描述错误，请各位同学留言指正。</p><h2 id="http请求和加载的优化"><a href="#http请求和加载的优化" class="headerlink" title="http请求和加载的优化"></a>http请求和加载的优化</h2><h3 id="一-减少http请求数量"><a href="#一-减少http请求数量" class="headerlink" title="一. 减少http请求数量"></a>一. 减少http请求数量</h3><p>在http1.1中，浏览器针对同一域名下的并发请求数量是一定的，换句话说同一域名浏览器在同一时间加载的资源（css、js或者是图片等）是一定的，一般4到5个，不同的浏览器稍有差异。因此优化目标可以分为以下两个方面：</p><ol><li>提高浏览器的并发请求所需资源的数量</li><li>合并资源，浏览器的每次请求可以获取更多的有用资源<br>因此我们可以针对以上两个方面进行优化。</li></ol><h4 id="1-适当的合并js、css和图片"><a href="#1-适当的合并js、css和图片" class="headerlink" title="1. 适当的合并js、css和图片"></a>1. 适当的合并js、css和图片</h4><p>可以使用webpack等打包工具把不经常修改的文件合并在一起。这样的话不仅可以减少请求数量，也可以很好的利用了http的缓存。</p><h4 id="2-适当的使用CSS-sprite也叫作CSS精灵"><a href="#2-适当的使用CSS-sprite也叫作CSS精灵" class="headerlink" title="2. 适当的使用CSS sprite也叫作CSS精灵"></a>2. 适当的使用CSS sprite也叫作CSS精灵</h4><p>通过使用图片合成工具把需要的各种小图标合并成一张大图标，再通过css的<code>background-position</code>来定位所需要的图片</p><h4 id="3-针对小图片也可以使用Data-RUL协议，这样图片被转换成base64编码的字符串形式-嵌入到了html中，这样在加载html时候图片资源也跟着html资源一起加载进来，减少了http请求数量；但是这样做的坏处是："><a href="#3-针对小图片也可以使用Data-RUL协议，这样图片被转换成base64编码的字符串形式-嵌入到了html中，这样在加载html时候图片资源也跟着html资源一起加载进来，减少了http请求数量；但是这样做的坏处是：" class="headerlink" title="3. 针对小图片也可以使用Data RUL协议，这样图片被转换成base64编码的字符串形式,嵌入到了html中，这样在加载html时候图片资源也跟着html资源一起加载进来，减少了http请求数量；但是这样做的坏处是："></a>3. 针对小图片也可以使用<a href="http://www.webhek.com/post/data-url.html" target="_blank" rel="noopener">Data RUL协议</a>，这样图片被转换成base64编码的字符串形式,嵌入到了html中，这样在加载html时候图片资源也跟着html资源一起加载进来，减少了http请求数量；但是这样做的坏处是：</h4><ol><li>Base64编码的数据体积通常是原数据的体积4/3，也就是Data URL形式的图片会比二进制格式的图片体积大1/3。</li><li>Data URL形式的图片不会被浏览器缓存，这意味着每次访问这样页面时都被下载一次。这是一个使用效率方面的问题——尤其当这个图片被整个网站大量使用的时候。</li></ol><div class="note primary"><p>如果想使用缓存，可以将Data URL形式的图片存储在CSS样式表中，而所有浏览器都会积极的缓存CSS文件来提高页面加载效率。具体操作可以参考<a href="http://www.webhek.com/post/data-url.html" target="_blank" rel="noopener">Data URL和图片</a></p></div><h4 id="4-可以把服务器资源放在不同的域名下，因为浏览器只会限制同一域名的请求并发数量，这样分别把不同的静态资源放入到不同的域名下，从而提高请求资源的并发数量。原理可以了解http请求头host的作用。"><a href="#4-可以把服务器资源放在不同的域名下，因为浏览器只会限制同一域名的请求并发数量，这样分别把不同的静态资源放入到不同的域名下，从而提高请求资源的并发数量。原理可以了解http请求头host的作用。" class="headerlink" title="4. 可以把服务器资源放在不同的域名下，因为浏览器只会限制同一域名的请求并发数量，这样分别把不同的静态资源放入到不同的域名下，从而提高请求资源的并发数量。原理可以了解http请求头host的作用。"></a>4. 可以把服务器资源放在不同的域名下，因为浏览器只会限制同一域名的请求并发数量，这样分别把不同的静态资源放入到不同的域名下，从而提高请求资源的并发数量。原理可以了解http请求头host的作用。</h4><h4 id="5-懒加载和预加载"><a href="#5-懒加载和预加载" class="headerlink" title="5. 懒加载和预加载"></a>5. 懒加载和预加载</h4><ul><li>懒加载：图片进入可视区域之后请求资源，对于电商，页面很长的场景，减少无效的资源加载（单页应用，观看的时候才去加载）。实现方法参考：图片的src的地址被改变的时候被加载。监听滑动的事件，当图片进入可视区域的时候才去加载。</li><li>预加载：与懒加载相反，预加载静态资源使用之前提前进行请求。直接从缓存中进行加载，不需要发送请求。</li></ul><h3 id="二-避免阻塞dom渲染"><a href="#二-避免阻塞dom渲染" class="headerlink" title="二. 避免阻塞dom渲染"></a>二. 避免阻塞dom渲染</h3><ol><li>CSS的加载不会阻塞DOM树的解析，但是会阻塞DOM树的渲染</li><li>CSS的加载会阻塞后面js语句的执行</li><li>js的加载和执行会阻塞DOM树的解析</li></ol><p>针对以上情况，优化点如下：</p><ol><li>css样式表置顶</li><li>用link代替import</li><li>js脚本置顶，放到body标签后面</li><li>合理使用js的异步加载能力</li></ol><h3 id="三-http缓存优化"><a href="#三-http缓存优化" class="headerlink" title="三. http缓存优化"></a>三. http缓存优化</h3><h3 id="四-通过Media-Query按需加载"><a href="#四-通过Media-Query按需加载" class="headerlink" title="四. 通过Media Query按需加载"></a>四. 通过Media Query按需加载</h3><h3 id="五-减少传输文件的大小"><a href="#五-减少传输文件的大小" class="headerlink" title="五. 减少传输文件的大小"></a>五. 减少传输文件的大小</h3><img src="/post/3048684187/main.jpeg"><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div class="note default"><p><a href="https://www.jianshu.com/p/fe32ef31deed" target="_blank" rel="noopener">前端性能优化总结</a><br>    <a href="https://www.cnblogs.com/dreamowneryong/p/4773201.html" target="_blank" rel="noopener">base64图片解析</a><br>     <a href="https://www.jianshu.com/p/10ca32480c1e" target="_blank" rel="noopener">base64和css sprites的区别</a><br>     <a href="https://harttle.land/2016/05/18/async-javascript-loading.html" target="_blank" rel="noopener">异步加载脚本</a><br>     <a href="https://juejin.im/post/59d489156fb9a00a571d6509" target="_blank" rel="noopener">浏览器渲染过程与性能优化</a><br>     <a href="https://blog.seosiwei.com/detail/33" target="_blank" rel="noopener">如何做到网页性能的极致优化</a></p></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;闲言&quot;&gt;&lt;a href=&quot;#闲言&quot; class=&quot;headerlink&quot; title=&quot;闲言&quot;&gt;&lt;/a&gt;闲言&lt;/h2&gt;&lt;p&gt;好的用户体验对于任何一个Web App都是一个非常重要的方面，想要拥有一个好的用户体验，网页的性能优化是必不可少的环节；特别是针对项目比较大
      
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>html页面渲染过程详解</title>
    <link href="http://yoursite.com/post/3918118019.html"/>
    <id>http://yoursite.com/post/3918118019.html</id>
    <published>2019-01-28T14:11:47.000Z</published>
    <updated>2019-01-31T15:23:49.786Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闲言"><a href="#闲言" class="headerlink" title="闲言"></a>闲言</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div class="note default"><p><a href="https://www.cnblogs.com/dojo-lzz/p/3983335.html" target="_blank" rel="noopener">HTML渲染过程详解</a><br><a href="https://www.cnblogs.com/chenjg/p/10099886.html" target="_blank" rel="noopener">你真的了解回流和重绘吗</a><br><a href="https://juejin.im/post/59d489156fb9a00a571d6509" target="_blank" rel="noopener">浏览器渲染过程与性能优化</a><br><a href="https://blog.csdn.net/cristina_song/article/details/77512534" target="_blank" rel="noopener">js执行会阻塞DOM树的解析和渲染，那么css加载会阻塞DOM树的解析和渲染吗</a></p></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;闲言&quot;&gt;&lt;a href=&quot;#闲言&quot; class=&quot;headerlink&quot; title=&quot;闲言&quot;&gt;&lt;/a&gt;闲言&lt;/h2&gt;&lt;h2 id=&quot;参考文献&quot;&gt;&lt;a href=&quot;#参考文献&quot; class=&quot;headerlink&quot; title=&quot;参考文献&quot;&gt;&lt;/a&gt;参考文献&lt;/h
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ES6的Rest参数和对象展开运算符</title>
    <link href="http://yoursite.com/post/3368437986.html"/>
    <id>http://yoursite.com/post/3368437986.html</id>
    <published>2019-01-26T07:16:31.000Z</published>
    <updated>2019-01-26T09:17:06.987Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闲言"><a href="#闲言" class="headerlink" title="闲言"></a>闲言</h2><p>ES6是ECMAScript标准十余年来变动最大的一个版本，其中添加了许多新的语法特性，既有大家耳熟能详的Promise，也有闻所未闻的Proxy代理和Reflection反射；既有可以通过转译器（Transpiler）等方式在旧版本浏览器中实现兼容的let、const、不定参数、展开运算符等功能，亦有无论如何都无法实现向前兼容的尾调用优化。深入理解ES6的特性对于所有JavaScript开发者而言至关重要，在可预见的未来，ES6中引入的语言特性会成为JavaScript应用程序的主流特性。因此本文探讨ES6中的两个重要且常用的特性，它们是Rest和对象展开运算符。由于本人知识有限，如有描述错误请留言指正。</p><h2 id="Rest参数"><a href="#Rest参数" class="headerlink" title="Rest参数"></a>Rest参数</h2><p>Rest参数接受函数的多余参数，组成一个数组，放在形参的最后；形式为<code>...变量名</code>。<strong>特别注意Rest参数只会出现在函数的形参中，否则都是对象的扩展</strong>，具体实例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function add(a, b, ...params) &#123;</span><br><span class="line">    console.log(params); //[ 3, 4, 5 ]</span><br><span class="line">    console.log(arguments); // &#123; &apos;0&apos;: 1, &apos;1&apos;: 2, &apos;2&apos;: 3, &apos;3&apos;: 4, &apos;4&apos;: 5 &#125;</span><br><span class="line">    let arguArray = Array.prototype.slice.apply(arguments);</span><br><span class="line">    // let arguArray = Array.from(arguments);</span><br><span class="line">    console.log(arguArray); //[ 1, 2, 3, 4, 5 ]</span><br><span class="line">    console.log(Array.isArray(arguArray)); // true</span><br><span class="line">    console.log(Array.isArray(params)); // true</span><br><span class="line">    console.log(Array.isArray(arguments)) // false</span><br><span class="line">&#125;</span><br><span class="line">add(1, 2, 3, 4, 5);</span><br></pre></td></tr></table></figure><br>上面实例代码可以看出：</p><ul><li>Rest参数只包括那些没有给出名称的参数，arguments包含所有参数。</li><li>arguments对象不是真正的数组，因此没有数组的一些方法特性；而Rest 参数是数组实例，因此拥有数组所有的方法特性。其实arguments是一个类似数组的伪数组（具有length属性，并且按照索引方式存储数据，但是不具有push()、pop()等数组方法，形式可以看上面代码3行），可以通过上面代码中4行或者是5行转换成真正的数组。<br>如果把Rest参数不放在函数形参的最后会怎么样呢？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function add(a, ...params, b) &#123;&#125;</span><br><span class="line">add(1, 2, 3, 4, 5);</span><br></pre></td></tr></table></figure>运行结果报错：<div class="note danger"><p>SyntaxError: Rest parameter must be last formal parameter</p></div><div class="note primary"><p>结果表明Rest参数之后不能再有其他参数，换句话说它必须是形参的最后一个参数！！！</p></div></li></ul><h3 id="Rest扩展知识"><a href="#Rest扩展知识" class="headerlink" title="Rest扩展知识"></a>Rest扩展知识</h3><p>Rest参数可以被结构解析(通俗一点，将rest参数的数据解析后一一对应)不要忘记参数用[]括起来，因为它是数组，实例代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function add(a, b, ...[c, d, e]) &#123;</span><br><span class="line">    console.log(a);</span><br><span class="line">    console.log(b);</span><br><span class="line">    console.log(c);</span><br><span class="line">    console.log(d);</span><br><span class="line">    console.log(e);</span><br><span class="line">&#125;</span><br><span class="line">add(1, 2, 3, 4, 5);</span><br><span class="line">add(1, 2, 3);</span><br><span class="line">add(1,2,3,4,5,6);</span><br></pre></td></tr></table></figure><br>结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">undefined</span><br><span class="line">undefined</span><br></pre></td></tr></table></figure><br>结果表明，结构解析中如果参数传递不够，对应的变量为undefined。</p><h2 id="展开运算符"><a href="#展开运算符" class="headerlink" title="展开运算符"></a>展开运算符</h2><p>扩展运算符（spread）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。展开运算符的应用场景非常之多。</p><ul><li><strong>可以很方便的实现对象的合并</strong>。比如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let object1 = &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let object2 = &#123;</span><br><span class="line">    a: 2,</span><br><span class="line">    c: 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let object3 = &#123;...object1, ...object2 &#125;;</span><br><span class="line">let object4 = &#123;...object2, a: 3, d: 4 &#125;;</span><br><span class="line">console.log(&apos;object3：&apos;, object3);</span><br><span class="line">console.log(&apos;object4：&apos;, object4);</span><br></pre></td></tr></table></figure>结果如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">object3： &#123; a: 2, b: 2, c: 3 &#125;</span><br><span class="line">object4： &#123; a: 3, c: 3, d: 4 &#125;</span><br></pre></td></tr></table></figure></li><li><strong>合并数组</strong><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let arr1 = [1, 2, 3];</span><br><span class="line">let arr2 = [4, 5];</span><br><span class="line">arr1.push(...arr2);</span><br><span class="line">console.log(arr1);</span><br></pre></td></tr></table></figure>结果如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ 1, 2, 3, 4, 5 ]</span><br></pre></td></tr></table></figure>如果你想要整合两个数组，并且想把某个数组放在另一个数组的任意特定位置上，你可以这么做：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr1 = [&apos;two&apos;, &apos;three&apos;];</span><br><span class="line">var arr2 = [&apos;one&apos;, ...arr1, &apos;four&apos;, &apos;five&apos;];</span><br><span class="line"></span><br><span class="line">// [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;]</span><br></pre></td></tr></table></figure></li><li><strong>拷贝数组</strong><br>之前我们拷贝数组可以通过slice和concat等方法，有了对象扩展运算符我们也可以这样：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr = [1, 2, 3];</span><br><span class="line">var arr2 = [...arr];</span><br><span class="line">arr2.push(4)</span><br><span class="line">console.log(&apos;arr2&apos;, arr2);</span><br><span class="line">console.log(&apos;arr&apos;, arr);</span><br></pre></td></tr></table></figure>结果如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr2 [ 1, 2, 3, 4 ]</span><br><span class="line">arr [ 1, 2, 3 ]</span><br></pre></td></tr></table></figure></li><li><strong>将arguments或者NodeList等伪数组转换为真正的数组</strong>。像这样：<br><code>[...arguments]</code>和<code>[...document.querySelectorAll(&#39;div&#39;)]</code></li></ul><p>还有其它一些应用不一一列举。需要注意的是：<br><div class="note primary"><p>展开运算符将数组“展开”成为不同的参数，所以任何可接收任意数量的参数的函数，都能够使用展开运算符来传参。比如：<code>Math.min(...[1,2,3]);</code></p></div></p><h2 id="Rest参数和对象展开运算符的关系"><a href="#Rest参数和对象展开运算符的关系" class="headerlink" title="Rest参数和对象展开运算符的关系"></a>Rest参数和对象展开运算符的关系</h2><ul><li>对象展开运算符就好比Rest参数的逆运算。</li><li>Rest参数是存在于形参当中，而对象展开运算符是不存在形参中的。</li><li>Rest参数作用于把传入的参数转化成数组，而对象扩展运算符是把不管是数组还是非数组对象扩展成一个个值。</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div class="note default"><p><a href="https://www.jianshu.com/p/50bcb376a419" target="_blank" rel="noopener">ES6 Rest参数</a><br><a href="https://www.jianshu.com/p/c5230c11781b" target="_blank" rel="noopener">ES6展开运算符的6种妙用</a></p></div> ]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;闲言&quot;&gt;&lt;a href=&quot;#闲言&quot; class=&quot;headerlink&quot; title=&quot;闲言&quot;&gt;&lt;/a&gt;闲言&lt;/h2&gt;&lt;p&gt;ES6是ECMAScript标准十余年来变动最大的一个版本，其中添加了许多新的语法特性，既有大家耳熟能详的Promise，也有闻所未闻的Pr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>通过css用div画出三角形</title>
    <link href="http://yoursite.com/post/2276870894.html"/>
    <id>http://yoursite.com/post/2276870894.html</id>
    <published>2019-01-19T04:41:13.000Z</published>
    <updated>2019-01-19T06:06:32.990Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闲言"><a href="#闲言" class="headerlink" title="闲言"></a>闲言</h2><p>通过css可以实现不同样式的三角形，其中的原理可以了解一下<a href="http://www.cnblogs.com/cchyao/archive/2010/07/12/1775846.html" target="_blank" rel="noopener">盒子模型</a>，闲言少叙，直接开始吧！</p><h2 id="基本入门"><a href="#基本入门" class="headerlink" title="基本入门"></a>基本入门</h2><p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot; /&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot; /&gt;</span><br><span class="line">    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot; /&gt;</span><br><span class="line">    &lt;title&gt;Static Template&lt;/title&gt;</span><br><span class="line">    &lt;style&gt;</span><br><span class="line">        .angel &#123;</span><br><span class="line">            display: inline-block;</span><br><span class="line">            border-width: 100px 100px 100px 100px;</span><br><span class="line">            border-color: red yellow green gray;</span><br><span class="line">            border-style: solid;</span><br><span class="line">            width: 50px;</span><br><span class="line">            height: 50px;</span><br><span class="line">            box-sizing: content-box;</span><br><span class="line">        &#125;</span><br><span class="line">    &lt;/style&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div class=&quot;angel&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><br>效果图如下：<br><img src="/post/2276870894/1.png"><br>代码17行作用是使用标准的盒子模型，如果使用IE盒子模型（box-sizing：border-box;），就不会出现中间的空白方块，大家可以自行测试。当我们调整width和height为5px，效果图如下：<br><img src="/post/2276870894/2.png"><br>当width和height为0时，效果图如下<br><img src="/post/2276870894/3.png"><br>感觉像不像四个三角形拼接在一起，如果我们想要绿色的三角形，我们可以把其它三个边框的颜色设置成transparent,代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.angel &#123;</span><br><span class="line">            display: inline-block;</span><br><span class="line">            border-width: 100px 100px 100px 100px;</span><br><span class="line">            border-color: transparent transparent green transparent;</span><br><span class="line">            border-style: solid;</span><br><span class="line">            box-sizing: content-box;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><br>效果图如下：<br><img src="/post/2276870894/4.png"><br>但是其它边的颜色已经透明，但是所占区域还是存在的，我们可以审查一下元素，如图所示：<br><img src="/post/2276870894/5.png"><br>因此我们把上边框的border-width设置为0，得到下图：<br><img src="/post/2276870894/6.png"><br>是不是我们想要达到的效果。我们也可以设置左边或者右边的border为0，得到该三角形其中的一半（也是一个三角形），代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.angel &#123;</span><br><span class="line">            display: inline-block;</span><br><span class="line">            border-width: 0 100px 100px 0;</span><br><span class="line">            border-color: transparent transparent green transparent;</span><br><span class="line">            border-style: solid;</span><br><span class="line">            box-sizing: content-box;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><br>效果图如下：<br><img src="/post/2276870894/7.png"><br>因此通过调整border不同方向的width和color，我们就可以得到任意不同方向的三角形。</p><h2 id="实战练习"><a href="#实战练习" class="headerlink" title="实战练习"></a>实战练习</h2><h3 id="1-实现一个角度为30度的直角三角形"><a href="#1-实现一个角度为30度的直角三角形" class="headerlink" title="1. 实现一个角度为30度的直角三角形"></a>1. 实现一个角度为30度的直角三角形</h3><p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.angel &#123;</span><br><span class="line">            display: inline-block;</span><br><span class="line">            border-width: 0px 100px 173px 0px;</span><br><span class="line">            border-color: transparent transparent green transparent;</span><br><span class="line">            border-style: solid;</span><br><span class="line">            box-sizing: content-box;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><br>如图所示：<br><img src="/post/2276870894/8.png"></p><h3 id="2-实现一个带有边框的三角形"><a href="#2-实现一个带有边框的三角形" class="headerlink" title="2. 实现一个带有边框的三角形"></a>2. 实现一个带有边框的三角形</h3><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div class="note default"><p><a href="http://www.cnblogs.com/v-weiwang/p/5057588.html" target="_blank" rel="noopener">css如何将div画成三角形</a></p></div> ]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;闲言&quot;&gt;&lt;a href=&quot;#闲言&quot; class=&quot;headerlink&quot; title=&quot;闲言&quot;&gt;&lt;/a&gt;闲言&lt;/h2&gt;&lt;p&gt;通过css可以实现不同样式的三角形，其中的原理可以了解一下&lt;a href=&quot;http://www.cnblogs.com/cchyao/ar
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Angualr介绍</title>
    <link href="http://yoursite.com/post/2552726188.html"/>
    <id>http://yoursite.com/post/2552726188.html</id>
    <published>2019-01-19T03:16:59.000Z</published>
    <updated>2019-01-19T04:33:30.023Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闲言"><a href="#闲言" class="headerlink" title="闲言"></a>闲言</h2><ol><li>编译的时候可以代码检查bug，从而减少运行时的bug</li><li>IDE更好的代码提示，和更快的性能</li><li>angular核心就是组件，装饰器模式</li><li>angular组件非常容易编写，装饰器模式更加人性化</li><li>服务器端渲染，可以增强性能也可以提高seo优化</li><li></li></ol><h2 id="Angular-CLI"><a href="#Angular-CLI" class="headerlink" title="Angular CLI"></a>Angular CLI</h2><h2 id="与React对比"><a href="#与React对比" class="headerlink" title="与React对比"></a>与React对比</h2><ol><li>React虚拟dom，先更新虚拟dom，在更新实际dom</li><li>Angular 新的变更检测算法</li><li>Angular 服务器端渲染，服务器预渲染首页加载优化，是seo引擎优化</li><li>单页缺陷是对seo很大缺陷</li></ol><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><p>不是完整的框架，第三方组件没有Angualr多</p><h2 id="VUE"><a href="#VUE" class="headerlink" title="VUE"></a>VUE</h2><p>简单<br>学习和使用不高，中文文档<br>cli更灵活<br>尺寸小，十几k<br>个人主导的，但是angular是google开发的，用的还是微软的typeScript<br>只关注web框架</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div class="note default"></div> ]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;闲言&quot;&gt;&lt;a href=&quot;#闲言&quot; class=&quot;headerlink&quot; title=&quot;闲言&quot;&gt;&lt;/a&gt;闲言&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;编译的时候可以代码检查bug，从而减少运行时的bug&lt;/li&gt;
&lt;li&gt;IDE更好的代码提示，和更快的性能&lt;/li&gt;
&lt;li&gt;a
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>http请求头origin和referer区别</title>
    <link href="http://yoursite.com/post/2885576345.html"/>
    <id>http://yoursite.com/post/2885576345.html</id>
    <published>2019-01-17T07:37:00.000Z</published>
    <updated>2019-01-19T03:07:08.172Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闲言"><a href="#闲言" class="headerlink" title="闲言"></a>闲言</h2><p>之前在做web项目中，每次使用chrome调试前端的时候经常会看到请求头header中经常会包含Referer和Origin字段，并且它俩的值有时长的还差不多，网上一查，它俩确实很相似，今天乘着闲暇的机会，整理一下它们各自的作用和区别。本人知识有限，如有错误欢迎留言指正。</p><h2 id="Referer"><a href="#Referer" class="headerlink" title="Referer"></a>Referer</h2><p>Referer其实应该是英文单词Referrer，不过拼错的人太多了，所以编写标准的人也就将错就错了。它是客户端请求头的一部分，当浏览器向web服务器发送请求的时候，<strong>一般会带上Referer</strong><font color="red">（不论是get请求还是post请求）</font>，告诉服务器我是从哪个页面链接过来的。比如说有个网址A：<code>https://mbd.baidu.com/newspage/data/landingsuper?context=%7B%22nid%22%3A%22news_1763945507961089360%22%7D&amp;n_type=0&amp;p_from=1</code>，A页面有个链接链接到了网站B：<code>https://mbd.baidu.com/newspage/data/landingsuper?context=%7B%22nid%22%3A%22news_9452777449866334360%22%7D&amp;n_type=0&amp;p_from=4</code>，如果你点击A页面的链接请求B页面，那么这时请求B页面的请求头中Referer就是A的网址：<code>https://mbd.baidu.com/newspage/data/landingsuper?context=%7B%22nid%22%3A%22news_9452777449866334360%22%7D&amp;n_type=0&amp;p_from=1</code>，你可以在B页面中调用浏览器的调试工具查看请求头验证一下。刚才说了<strong>一般会带上Referer</strong>，那么什么情况下不会带上呢？根据自己的验证和别人的分享，我总结出Referer的存在需要具备两个要素：</p><ol><li>浏览器（客户端）请求（服务器端请求的情况下，是不存在referer的，但是可以伪造header）</li><li>存在前导页，就是你的页面是从哪个页面链接过来的</li></ol><p>因此根据这两个要素，可以大致列举出不会带上Referer的几种情况如下：</p><ul><li>在浏览器内直接敲URL（没有前导页）</li><li>windows桌面上的超链接图标（原因同上）</li><li>浏览器内书签（同上）</li><li>第三方软件（如Word，Excel等）内容中的链接（不是浏览器）</li><li>使用JavaScript的Location.href或者是Location.replace()</li><li>SSL认证网站跳入(网站部署SSL证书后，可以通过在服务器设置301重定向让HTTP自动跳转到HTTPS，也可以通过设置JS跳转实现HTTP自动跳转到HTTPS）<br>然而在以下两种情况下，Referer不会被发送：</li></ul><ol><li>来源页面采用的协议为表示本地文件的 “file” 或者 “data” URI</li><li>当前请求页面采用的是非安全协议，而来源页面采用的是安全协议（HTTPS）</li></ol><div class="note danger"><p>Referer 首部可能暴露用户的浏览历史，涉及到用户的隐私问题。</p></div><h2 id="Referer的作用"><a href="#Referer的作用" class="headerlink" title="Referer的作用"></a>Referer的作用</h2><ul><li>统计访问这个页面从哪个前导页链接过来的次数</li><li>防止盗链，盗链的解释，请参考<a href="https://baike.baidu.com/item/%E7%9B%97%E9%93%BE?fr=aladdin" target="_blank" rel="noopener">百度百科</a>，当一个请求到达服务器，特别是CDN服务器的时候，CDN服务器可以根据该字段来判断来源站点是否是合作伙伴，或者是可信任的，然后再决定是否将资源返回给它</li><li>防止恶意请求，比如说只允许外部网站访问我的静态资源，对于动态资源，不允许从外部网站访问，这样在一定程度上可以避免CSRF攻击。当然了，依赖客户端的请求是很不可靠的，因为这个可以轻轻松松伪造。</li></ul><h2 id="Origin"><a href="#Origin" class="headerlink" title="Origin"></a>Origin</h2><p>请求首部字段 Origin 指示了请求来自于哪个站点。<strong>该字段仅指示服务器名称，并不包含任何路径信息</strong>。该首部<strong>只用于 CORS 请求或者 POST 请求</strong>。除了不包含路径信息，该字段与 Referer 首部字段相似。表现形式如下：<br><div class="note primary"><p>Origin: “”<br>Origin: <scheme> “://“ <host> [ “:” <port> ]</port></host></scheme></p></div><br>有时候将该字段的值置空是有用的，例如，资源由一个 data URL 指定</p><h2 id="Origin的作用"><a href="#Origin的作用" class="headerlink" title="Origin的作用"></a>Origin的作用</h2><p>从上面可以看出，其实referrer所能满足的要求，origin全部都能达到，事实上，origin的提出，本身就是在HTML5中跨域操作所引入的。 其具体流程是，当一个链接或者XMLHttpRequest去请求跨域操作，浏览器事实上的确向目标服务器发起了连接请求，并且携带这origin。 当服务器返回时，浏览器将检查response中是否包Access-Control-Allow-Origin字段，当缺少这个字段时，浏览器将abort，abort的意思是不显示，不产生事件，就好像没有请求过，甚至在network区域里面都看不到。 当存在这个header时，浏览器将检查当前请求所在域是否在这个access-control-allow-origin所允许的域内，如果是，继续下去，如果不存在，abort！</p><h2 id="两者主要区别"><a href="#两者主要区别" class="headerlink" title="两者主要区别"></a>两者主要区别</h2><ul><li>Origin不包含前导页任何的路径信息，但是Referer包含了前导页的路径信息，可能会透露出用户信息或者是用户浏览历史等隐私信息，因此Origin相对比Referer安全。</li><li>Referer不论是get请求和post请求都会存在，Origin当出现CORS时get和post请求都会出现，否则只会出现在post请求中。</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div class="note default"><p><a href="https://blog.csdn.net/fishmai/article/details/52388840" target="_blank" rel="noopener">Referer详解</a><br><a href="https://blog.csdn.net/zdavb/article/details/51161130" target="_blank" rel="noopener">彻底搞清referrer和origin</a></p></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;闲言&quot;&gt;&lt;a href=&quot;#闲言&quot; class=&quot;headerlink&quot; title=&quot;闲言&quot;&gt;&lt;/a&gt;闲言&lt;/h2&gt;&lt;p&gt;之前在做web项目中，每次使用chrome调试前端的时候经常会看到请求头header中经常会包含Referer和Origin字段，并且它俩的
      
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
      <category term="header" scheme="http://yoursite.com/tags/header/"/>
    
      <category term="Origin" scheme="http://yoursite.com/tags/Origin/"/>
    
      <category term="Referer" scheme="http://yoursite.com/tags/Referer/"/>
    
  </entry>
  
  <entry>
    <title>详解http请求头host</title>
    <link href="http://yoursite.com/post/3695960831.html"/>
    <id>http://yoursite.com/post/3695960831.html</id>
    <published>2019-01-17T07:33:00.000Z</published>
    <updated>2019-01-17T15:49:38.860Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="http" scheme="http://yoursite.com/tags/http/"/>
    
      <category term="header" scheme="http://yoursite.com/tags/header/"/>
    
      <category term="host" scheme="http://yoursite.com/tags/host/"/>
    
  </entry>
  
  <entry>
    <title>http header详解</title>
    <link href="http://yoursite.com/post/956247918.html"/>
    <id>http://yoursite.com/post/956247918.html</id>
    <published>2019-01-16T11:57:00.000Z</published>
    <updated>2019-01-16T14:46:12.919Z</updated>
    
    <content type="html"><![CDATA[<div class="note class_name"><p><a href="https://segmentfault.com/a/1190000008900299" target="_blank" rel="noopener">HTTP 最强资料大全</a><br><a href="http://www.cnblogs.com/Joans/p/3956490.html" target="_blank" rel="noopener">HTTP Header 详解</a></p></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;note class_name&quot;&gt;&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000008900299&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;HTTP 最强资料大全&lt;/a&gt;&lt;br&gt;&lt;a h
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>http状态码详解</title>
    <link href="http://yoursite.com/post/432560822.html"/>
    <id>http://yoursite.com/post/432560822.html</id>
    <published>2019-01-16T11:13:29.000Z</published>
    <updated>2019-01-18T15:57:57.455Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1xx：指示信息，表示请求被接受，正在处理"><a href="#1xx：指示信息，表示请求被接受，正在处理" class="headerlink" title="1xx：指示信息，表示请求被接受，正在处理"></a>1xx：指示信息，表示请求被接受，正在处理</h2><ol><li>101 Switching Protocols：服务器将遵从客户端的请求转换到另外一种协议（HTTP1.1）</li></ol><h2 id="2xx：成功，表示请求正常处理完毕"><a href="#2xx：成功，表示请求正常处理完毕" class="headerlink" title="2xx：成功，表示请求正常处理完毕"></a>2xx：成功，表示请求正常处理完毕</h2><ol><li>200 OK（成功）:客户端请求成功</li><li>204 No Content（无内容）：服务器成功处理了请求，但没有返回任何内容。</li><li>206 Partial Content（部分内容）：客户发送了一个带有Range头的GET请求，服务器完成了它（代表服务器根据Range头返回了部分内容）</li></ol><h2 id="3xx：重定向，完成请求必须进行跟进一步的操作"><a href="#3xx：重定向，完成请求必须进行跟进一步的操作" class="headerlink" title="3xx：重定向，完成请求必须进行跟进一步的操作"></a>3xx：重定向，完成请求必须进行跟进一步的操作</h2><ol><li>301 Moved Permanently（永久移动）：所请求的页面已经永久转移至新的url，服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新url</li><li>302 Moved Provisionally（临时移动）：服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求</li><li>304 Not Modified（未修改）：自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容</li></ol><h2 id="4xx：客户端错误，请求有语法错误或者请求无法实现从而导致服务器无法处理请求"><a href="#4xx：客户端错误，请求有语法错误或者请求无法实现从而导致服务器无法处理请求" class="headerlink" title="4xx：客户端错误，请求有语法错误或者请求无法实现从而导致服务器无法处理请求"></a>4xx：客户端错误，请求有语法错误或者请求无法实现从而导致服务器无法处理请求</h2><ol><li>400 Bad Request（错误请求）：服务器不理解请求的语法</li><li>401 Unauthorized（请求未授权）：请求要求身份验证即发送请求需要Http的认证信息。 对于需要登录的网页，服务器可能返回此响应。</li><li>403 Forbidden（禁止访问）：请求资源的访问被拒绝</li><li>404 Not Found（没发现）：请求资源不存在</li></ol><h2 id="5xx：服务器处理请求出错-服务器未能实现合法的请求"><a href="#5xx：服务器处理请求出错-服务器未能实现合法的请求" class="headerlink" title="5xx：服务器处理请求出错,服务器未能实现合法的请求"></a>5xx：服务器处理请求出错,服务器未能实现合法的请求</h2><ol><li>500 Internal Server Error（服务器端错误）：服务器发生不可预期的错误</li><li>503 Server Unavailable（服务器不可用）：服务器目前无法使用（由于超载或停机维护）； 通常，这只是暂时状态</li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div class="note default"><p><a href="https://blog.csdn.net/hangmine/article/details/79010025" target="_blank" rel="noopener">常见的HTTP状态码(HTTP Status Code)说明</a><br><a href="https://segmentfault.com/a/1190000008900299" target="_blank" rel="noopener">HTTP 最强资料大全</a><br><a href="http://www.cnblogs.com/scyitgz/p/5216031.html" target="_blank" rel="noopener">一鸣先生 手稿</a><br><a href="https://blog.csdn.net/Rnger/article/details/82425961" target="_blank" rel="noopener">状态码401 和 403</a></p></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1xx：指示信息，表示请求被接受，正在处理&quot;&gt;&lt;a href=&quot;#1xx：指示信息，表示请求被接受，正在处理&quot; class=&quot;headerlink&quot; title=&quot;1xx：指示信息，表示请求被接受，正在处理&quot;&gt;&lt;/a&gt;1xx：指示信息，表示请求被接受，正在处理&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>深入理解vue的computed和watch区别</title>
    <link href="http://yoursite.com/post/21176862.html"/>
    <id>http://yoursite.com/post/21176862.html</id>
    <published>2019-01-12T03:19:58.000Z</published>
    <updated>2019-01-14T12:55:17.527Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闲言"><a href="#闲言" class="headerlink" title="闲言"></a>闲言</h2><h2 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h2><p>监控计算属性的变化（被动变化），主要是根据计算属性中所依赖值发生变化，从而得到新的值，计算属性可以不再data属性中申明，如果计算属性依赖的属性发生了变化，就会运行该computed函数得到计算属性新值，反之如果需要用到计算属性，就会从缓存里面去取，因此比methods性能更佳，其次Vue中的计算属性都是同步的，如果需要异步我们得依赖于<a href="https://github.com/foxbenjaminfox/vue-async-computed" target="_blank" rel="noopener">vue-async-computed</a>。<br>   <img src="/post/21176862/1.png"><br>   代码示例：<br>      <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;p id=&quot;app&quot;&gt;&#123; &#123; fullName &#125; &#125;&lt;/p&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var vm = new Vue(&#123;  </span><br><span class="line">        el: &apos;#app&apos;,  </span><br><span class="line">        data: &#123;  </span><br><span class="line">            firstName: &apos;Foo&apos;,  </span><br><span class="line">            lastName: &apos;Bar&apos;,  </span><br><span class="line">        &#125;,  </span><br><span class="line">        computed: &#123;  </span><br><span class="line">            fullName: function () &#123;  </span><br><span class="line">                return this.firstName + &apos; &apos; + this.lastName  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">      </span><br></pre></td></tr></table></figure><br>代码中fullName就是计算属性，它所依赖的属性为firstName和lastName，如果它们发生任何变化，都会调用该计算属性函数，如果依赖没有变化，则不会调用，当需要fullName时候，会从缓存里面取。<br>计算属性默认是只有ES6的getter，当然可以在需要的时候自己设定ES6的setter:<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//...</span><br><span class="line">computed: &#123;</span><br><span class="line">    fullName: &#123;</span><br><span class="line">        // getter</span><br><span class="line">        get: function () &#123;</span><br><span class="line">            return this.firstName + &apos; &apos; + this.lastName</span><br><span class="line">        &#125;,</span><br><span class="line">        // setter</span><br><span class="line">        set: function (newValue) &#123;</span><br><span class="line">            var names = newValue.split(&apos; &apos;)</span><br><span class="line">            this.firstName = names[0]</span><br><span class="line">            this.lastName = names[names.length - 1]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br></pre></td></tr></table></figure><br>那么问题来了，既然computed有setter方法，不知道大家是不是和我想法一样，这样setter不就可以取代了watch了吗？关于这个疑问，我觉得有几点可以说明：</p><ol><li>watch函数可以传来两个参数，一个是新值一个是旧值，而计算属性函数只有一个新值的参数，虽然可以使用其它办法来获取旧值。   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line"> return &#123;</span><br><span class="line">     frontPoints: 0    </span><br><span class="line">   &#125;</span><br><span class="line"> &#125;,</span><br><span class="line"> watch: &#123;</span><br><span class="line">     frontPoints(newValue, oldValue) &#123;</span><br><span class="line">         console.log(newValue)</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line">      </span><br></pre></td></tr></table></figure></li><li>watch可以监控对象属性的变化,而setter不能是对象属性，个人觉得这一点是关键。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">　　return &#123;</span><br><span class="line">　　　　bet: &#123;</span><br><span class="line">　　　　　　pokerState: 53,</span><br><span class="line">　　　　　　pokerHistory: &apos;local&apos;</span><br><span class="line">　　　　&#125;   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">watch: &#123;</span><br><span class="line">　　bet: &#123;</span><br><span class="line">　　　　handler(newValue, oldValue) &#123;</span><br><span class="line">　　　　　　console.log(newValue)</span><br><span class="line">　　　　&#125;,</span><br><span class="line">　　　　deep: true</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>        <h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2>监控data中属性的变化（主动变化），如果该属性值变化，则会调用该watch函数，主要用来修改其它属性变量或处理一些复杂逻辑和异步操作；该变量必须是data中有的属性。<img src="/post/21176862/2.png">代码示例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">        el: &apos;#app&apos;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            firstName: &apos;Foo&apos;,</span><br><span class="line">            lastName: &apos;Bar&apos;,</span><br><span class="line">            fullName: &apos;Foo Bar&apos;</span><br><span class="line">        &#125;,</span><br><span class="line">        watch: &#123;</span><br><span class="line">            firstName: function (val) &#123;</span><br><span class="line">                this.fullName = val + &apos; &apos; + this.lastName</span><br><span class="line">            &#125;,</span><br><span class="line">            lastName: function (val) &#123;</span><br><span class="line">                this.fullName = this.firstName + &apos; &apos; + val</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">   </span><br></pre></td></tr></table></figure>当watch中的firstName和lastName值发生变化时，就会调用各自的函数。<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div class="note default"><p><a href="https://www.w3cplus.com/vue/methods-computed-and-watchers-in-vue-js.html" target="_blank" rel="noopener">Vue中的方法，属性计算和观察者</a><br><a href="https://www.w3cplus.com/vue/vue-computed-intro.html" target="_blank" rel="noopener">Vue 2.0学习笔记： Vue中的computed属性</a><br>(<a href="https://blog.csdn.net/webxiaoma/article/details/72626439" target="_blank" rel="noopener">https://blog.csdn.net/webxiaoma/article/details/72626439</a>)<br>   <a href="https://www.cnblogs.com/widgetbox/p/8954162.html" target="_blank" rel="noopener">vue中methods、watch、computed之间的差别对比以及适用场景</a><br>   <a href="https://blog.csdn.net/zhumengzj/article/details/78742069" target="_blank" rel="noopener">vuejs - 如何对某个对象的属性进行watch监听？</a><br>   <a href="https://blog.csdn.net/u014298440/article/details/82942680" target="_blank" rel="noopener">Vue使用watch监听一个对象中的属性</a><br>   <a href="https://www.w3cplus.com/vue/methods-computed-and-watchers-in-vue-js.html" target="_blank" rel="noopener">Vue中的方法，属性计算和观察者</a></p></div> </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;闲言&quot;&gt;&lt;a href=&quot;#闲言&quot; class=&quot;headerlink&quot; title=&quot;闲言&quot;&gt;&lt;/a&gt;闲言&lt;/h2&gt;&lt;h2 id=&quot;computed&quot;&gt;&lt;a href=&quot;#computed&quot; class=&quot;headerlink&quot; title=&quot;computed&quot;
      
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
  </entry>
  
  <entry>
    <title>Angular, Vue, React数据双向绑定原理</title>
    <link href="http://yoursite.com/post/3623552453.html"/>
    <id>http://yoursite.com/post/3623552453.html</id>
    <published>2019-01-09T11:35:59.000Z</published>
    <updated>2019-01-14T12:59:07.394Z</updated>
    
    <content type="html"><![CDATA[<div class="note default"><p><a href="https://www.jianshu.com/p/0520e1e8d23d" target="_blank" rel="noopener">angular,vue,react数据双向绑定原理分析</a><br><a href="https://www.cnblogs.com/samsara-yx/p/9456638.html" target="_blank" rel="noopener">angular 双向数据绑定与vue数据的双向数据绑定</a></p></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;note default&quot;&gt;&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/0520e1e8d23d&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;angular,vue,react数据双向绑定原理分析&lt;/a&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>细说table和div布局的优缺点</title>
    <link href="http://yoursite.com/post/4067833097.html"/>
    <id>http://yoursite.com/post/4067833097.html</id>
    <published>2019-01-09T10:51:00.000Z</published>
    <updated>2019-01-14T12:58:13.345Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闲言"><a href="#闲言" class="headerlink" title="闲言"></a>闲言</h2><p>一开始接触前端时候使用的是table布局，当时感觉table布局真的很方便，并且可以使用DW软件来自动生成；但是随着所开发的页面复杂化和对性能的要求越来越高，table布局渐渐的展现出来它的不足了；现在table的布局方式已经被div+css布局方式替代了，但是也不排除市面上还有一些老系统仍然是table布局；下面针对这两种布局方式（<strong><em>table布局</em></strong>和<strong><em>div+css布局</em></strong>）来详细的讲解一下它们各自的优缺点。如有描述不正确，欢迎留言指正。</p><h2 id="div-css布局优缺点"><a href="#div-css布局优缺点" class="headerlink" title="div+css布局优缺点"></a>div+css布局优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol><li>可以通过css样式给框架进行功能强大的属性设置以及给网页的局部进行任意的定位，制作出来的页面浏览速度较快，</li><li>页面的风格可以通过修改单独的css文件进行随意的修改和更新。</li></ol><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>对于开发者来说可能不熟悉css的开发人员来说上手比较慢，开发时间可能比较长。</p><h2 id="table布局优缺点"><a href="#table布局优缺点" class="headerlink" title="table布局优缺点"></a>table布局优缺点</h2><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ol><li>开发时间短（使用DW开发速度快）。</li><li>纯table各浏览器不会有兼容问题。</li><li>内容可自适应。</li><li>在搜索引擎排名能靠前。</li></ol><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ol><li>如果布局变更，需要重新开发，灵活性比较差。</li><li>如果table里有div ul 等，可能会出现浏览器兼容问题。</li><li>加载速度慢<div class="note primary"><p>由于html文件中的table标签的浏览速度较慢，所以，使用嵌套表格的方法来布局网页框架会使网页浏览的速度变慢。因为table是中的内容是自适应的，为了自适应，它要计算嵌套最深的节点以满足自适应，所以有可能会有一断时间出现空白才显示。所以是会有问题的。 </p></div></li></ol><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div class="note default"><p><a href="https://www.cnblogs.com/nwj-0613/p/4775854.html" target="_blank" rel="noopener">HTML中table和div布局的优缺点</a></p></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;闲言&quot;&gt;&lt;a href=&quot;#闲言&quot; class=&quot;headerlink&quot; title=&quot;闲言&quot;&gt;&lt;/a&gt;闲言&lt;/h2&gt;&lt;p&gt;一开始接触前端时候使用的是table布局，当时感觉table布局真的很方便，并且可以使用DW软件来自动生成；但是随着所开发的页面复杂化和对性
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用hexo-admin随时随地发布hexo博客</title>
    <link href="http://yoursite.com/post/2981499989.html"/>
    <id>http://yoursite.com/post/2981499989.html</id>
    <published>2019-01-08T16:58:55.000Z</published>
    <updated>2019-01-23T16:27:52.381Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闲言"><a href="#闲言" class="headerlink" title="闲言"></a>闲言</h2><p>之前通过github page和hexo框架搭建了一个博客系统，一开始在自己的电脑上写完hexo博客，然后敲点命令发布到github上，过程感觉不算太麻烦；但是如果当我们换一台电脑或者是你在公司或者网吧的时候一时兴起想写博客，那么你就必须要在手头上的电脑中配置hexo环境所需要的一系列依赖（其中的麻烦你懂的），才能写博客发布你的博客。为了能够更方便的随时随地都能写博客发布博客,我使用hexo-admin搭建了一个在线的hexo博客后台管理系统，下面我就来详细的讲解一下我的搭建流程，希望能够给大家带来帮助，如果描述有误，欢迎大家留言指正。</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>本人自己有一台阿里云服务器，但是考虑到稳定性和安全性等问题，最后将hexo的静态页面部署github-pages上。现在我的需求有：</p><ol><li>拥有在线编辑博客的后台</li><li>本地机器同时也可以编辑发布博客</li><li>本地和线上要保持同步</li><li>由于我使用的是next的主题，也希望修改的主题功能也可以方便的同步</li></ol><h2 id="我所用到的工具"><a href="#我所用到的工具" class="headerlink" title="我所用到的工具"></a>我所用到的工具</h2><ol><li>hexo-admin</li><li>阿里云服务器</li><li>coding.net一个可以创建免费私有仓库的git服务器</li><li>github page</li></ol><h2 id="搭建步骤"><a href="#搭建步骤" class="headerlink" title="搭建步骤"></a>搭建步骤</h2><ol><li>首先安装hexo-admin管理包，我的博客工程名称为blog，我就以blog来说，进入blog文件夹通过<code>npm install hexo-admin --save</code>（如果被墙可以使用<a href="https://npm.taobao.org/" target="_blank" rel="noopener">淘宝NPM镜像</a>）或者是<code>yarn add hexo-admin --save</code>（不懂yarn命令的可以自行百度）来安装hexo-admin。安装成功后我们可以使用命令<code>hexo s -d</code>来启动博客，之后访问‘localhost:4000/admin’打开博客管理系统，界面如下图：<img src="/post/2981499989/hexo_admin.png"></li><li>本地搭建后台管理系统成功，但是这样每个人都能访问我们的管理系统，因此我们需要为管理系统添加登录功能；为了实现该功能我们需要在<code>_config.yml</code>添加hexo-admin的admin选项，如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">admin:</span><br><span class="line">  username: </span><br><span class="line">  password_hash: </span><br><span class="line">  secret: my super secret phrase</span><br><span class="line">  deployCommand: &apos;./hexo-deploy.sh&apos;</span><br></pre></td></tr></table></figure><code>username</code>是用户名可以自己任意起名，<code>password_hash</code>需要在步骤1中打开的博客管理系统中的Settings中获取，如下图：<img src="/post/2981499989/hexo_admin1.png">按图示点击，可以进入到以下界面：<img src="/post/2981499989/password.png">界面中画上红色圈的是我们填入的，可以任意填，之后你会看到username和password_hash会自动生成，入蓝色圈圈所示，把蓝色框中的值复制到对应的我们在<code>_config.yml</code>配置的admin选项中即可，如果配置成功，这时你重新打开管理系统就可以看到登录窗口，输入用户名和密码即可登录成功,如下图：<img src="/post/2981499989/login.png">对于<code>deployCommand</code>是你需要填入的执行脚本路径，该脚本是需要自己创建的，作用是在线发布博客（点击博客后台管理系统中Deploy选项的Deploy按钮即可一键部署)，其原理是通过node.js中的<code>child_process.spawn</code>来执行我们创建的部署脚本程序，脚本程序<code>hexo-deploy.sh</code>代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">echo &quot;start&quot;</span><br><span class="line">./server-upload.sh</span><br><span class="line">hexo clean </span><br><span class="line">hexo g</span><br><span class="line">gulp</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>上面代码的第4、5、7行是基本的hexo部署命令，不在累述，第6行是gulp命令，专门用来压缩静态资源文件（不懂的可以自行百度，这里不在累述），代码第3行引入了另一个脚本<code>server-upload.sh</code>，该脚本专门同步coding.net仓库中的源代码和merge代码，源码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git commit -m &apos;merge&apos;</span><br><span class="line">git pull origin master</span><br><span class="line">git add .</span><br><span class="line">git commit -m &apos;upload source code&apos;</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure></li><li>为了保持博客的源代码线上线下同步，我把它托管到了coding.net中，这样就可以通过git来保持源代码的一致性（不要忘了给你的本地电脑和线上服务器配置公钥，否则每次都需要输入用户名和密码）；具体配置可以自行百度，这里不再累述。</li><li>我的博客用的是next主题。由于主题也是通过git clone下来的，一开始我是把next主题也一起同步到coding.net仓库中，但是当我再重新从我的仓库中git clone我的博客后，运行<code>hexo s -d</code>命令是会报错误<code>no the layout named index.html</code>，网上查了一下，必须要独立的git clone才能没有问题。因此我单独为next主题创建了coding.net仓库，之后通过在blog/themes文件夹下git clone主题即可。如果我修改了next主题，也需要及时的merge到coding.net仓库中，这样才能保持next主题同步。还有一点需要注意的是主题文件修改之后，你再进行复制主题文件，你会惊奇的发现，你复制的主题文件又回到了你修改之前的状态，因此这点需要主题，必要的时候你需要对比文件手动修改。</li><li>有了本地的后台管理系统，也把博客和主题源代码托管到coding.net中了，但是我们还需要把它部署到线上，这样我们才能随时随地可以通过浏览器访问；我是通过阿里云服务器搭建的hexo系统，具体搭建步骤和本地一模一样。就是通过git命令把博客和主题源代码clone下来，之后通过<code>npm install</code>或者<code>yarn install</code>命令下载依赖包，这样就搭建成功，是不是很简单！！！。一开始我们使用<code>hexo s -d</code>来启动我们的后台管理系统，但是如果我们退出该命令，或者命令窗口关闭，则该进程就关闭了，为了可以让博客管理系统可以一直在后台进程运行，可以使用<code>nohup hexo s -d -p 80 &amp;</code>命令，其中<code>-p 80</code>是指定端口号为80端口，也可以不写，因为默认是4000端口。</li><li>如果以上步骤都配置成功，就可以通过你的<code>服务器IP+端口号/admin</code>进入在线博客后台系统了，你可以编辑你的博客、添加博客等等，之后点击deploy按钮（可能等待时间会长一点）,如果部署成功会出现以下界面：<img src="/post/2981499989/deploy.png"><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div class="note default"><p><a href="https://www.jianshu.com/p/68e727dda16d" target="_blank" rel="noopener">如何优雅地发布Hexo博客</a><br><a href="https://segmentfault.com/a/1190000010434546" target="_blank" rel="noopener">hexo-admin后台管理博客</a><br><a href="https://www.jianshu.com/p/d174a6dc1b94" target="_blank" rel="noopener">Hexo博客SEO优化</a><br><a href="https://www.jianshu.com/p/393d067dba8d" target="_blank" rel="noopener">Hexo之next主题设置首页不显示全文(只显示预览)</a><br><a href="https://www.cnblogs.com/fengxiongZz/p/7707219.html" target="_blank" rel="noopener">使用Hexo+Github一步步搭建属于自己的博客（基础）</a><br><a href="https://segmentfault.com/a/1190000009544924" target="_blank" rel="noopener">hexo的next主题个性化配置教程</a><br><a href="https://www.jianshu.com/p/2f39de746900" target="_blank" rel="noopener">word在线预览功能</a><br><a href="https://github.com/MikeCoder/hexo-blog-encrypt/blob/master/ReadMe.zh.md" target="_blank" rel="noopener">hexo-blog-encrypt博客加密插件</a><br><a href="https://www.jianshu.com/p/1ff2fcbdd155" target="_blank" rel="noopener">Hexo博客第三方主题next进阶教程</a><br><a href="http://blog.heyuhua.xyz/2018/09/08/hexo+next%E8%AE%BE%E7%BD%AE%E7%9B%B8%E5%85%B3/" target="_blank" rel="noopener">hexo+next设置相关</a><br><a href="https://blog.csdn.net/blue_zy/article/details/79071414" target="_blank" rel="noopener">为你的Hexo加上评论系统-Valine</a></p></div></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;闲言&quot;&gt;&lt;a href=&quot;#闲言&quot; class=&quot;headerlink&quot; title=&quot;闲言&quot;&gt;&lt;/a&gt;闲言&lt;/h2&gt;&lt;p&gt;之前通过github page和hexo框架搭建了一个博客系统，一开始在自己的电脑上写完hexo博客，然后敲点命令发布到github上，过程
      
    
    </summary>
    
      <category term="hexo" scheme="http://yoursite.com/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
      <category term="next" scheme="http://yoursite.com/tags/next/"/>
    
      <category term="hexo-admin" scheme="http://yoursite.com/tags/hexo-admin/"/>
    
  </entry>
  
  <entry>
    <title>CSS左边固定右边自适应布局的几种方式</title>
    <link href="http://yoursite.com/post/915039209.html"/>
    <id>http://yoursite.com/post/915039209.html</id>
    <published>2019-01-06T04:56:19.000Z</published>
    <updated>2019-01-14T12:55:17.524Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闲言"><a href="#闲言" class="headerlink" title="闲言"></a>闲言</h2><p>在我们平常的布局中两栏布局是很常见的一种布局方式，并且对于两栏布局的实现方式也是层出不穷；之前忙于工作和happy，没有时间去整理这方面知识，今天抽空总结一下，一方面可以提升和巩固自己的知识，二者也可以分享给大伙儿，更易于大家的理解和掌握。由于自己的水平有限，如果文章有任何问题，欢迎大家积极留言评论指正。</p><h2 id="1-根据css计算属性calc和display-inline-block实现左边固定右边自适应布局"><a href="#1-根据css计算属性calc和display-inline-block实现左边固定右边自适应布局" class="headerlink" title="1. 根据css计算属性calc和display:inline-block实现左边固定右边自适应布局"></a>1. 根据css计算属性calc和display:inline-block实现左边固定右边自适应布局</h2><iframe src="https://codesandbox.io/embed/2wq24y4wnp" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p> 在display:inline-block中，如何有换行符和空格符的话，就会产生inline-block元素之前有间隙，因此我们在父元素中把字符的font-size设为0。关于inlin-block去间隙问题可以参考：<a href="https://blog.csdn.net/gladys_1111/article/details/77279985" target="_blank" rel="noopener">inline-block布局产生间隙的原因及解决办法（水平、垂直）</a>。</p><h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3> <img src="/post/915039209/calc.png"><h2 id="2-根据css计算属性calc和display-float实现左边固定右边自适应布局"><a href="#2-根据css计算属性calc和display-float实现左边固定右边自适应布局" class="headerlink" title="2. 根据css计算属性calc和display:float实现左边固定右边自适应布局"></a>2. 根据css计算属性calc和display:float实现左边固定右边自适应布局</h2><iframe src="https://codesandbox.io/embed/1zr2zj18o4" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe><h2 id="3-根据float和margin实现左边固定右边自适应布局"><a href="#3-根据float和margin实现左边固定右边自适应布局" class="headerlink" title="3. 根据float和margin实现左边固定右边自适应布局"></a>3. 根据float和margin实现左边固定右边自适应布局</h2><iframe src="https://codesandbox.io/embed/yv48893om1" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe><h3 id="Note-1"><a href="#Note-1" class="headerlink" title="Note"></a>Note</h3><p>因为左边是浮动布局，右边是块布局，因此右边的div会自动充满一行；如果右边不设置margin，那么右边的一部分就和左边重叠，加入我们要给右边要设置左边边框，那么就达不到我们想要的效果。因此我们通过设置margin-left为左边的宽度，使得左右刚好不重叠。</p><h2 id="4-根据float和overflow实现左边固定右边自适应布局"><a href="#4-根据float和overflow实现左边固定右边自适应布局" class="headerlink" title="4. 根据float和overflow实现左边固定右边自适应布局"></a>4. 根据float和overflow实现左边固定右边自适应布局</h2><iframe src="https://codesandbox.io/embed/jp3x90vml3" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe><h3 id="Note-2"><a href="#Note-2" class="headerlink" title="Note"></a>Note</h3><p>这种实现方式感觉和上面一种实现方式很像，区别就是上面通过margin来处理重叠，而本方法是通过overflow：hidden来处理重叠，其原理是如果元素设置了overflow:hidden，这样就使它成为了一个BFC容器，因为BFC有个规则是：<strong>BFC的区域不会与float box重叠</strong>，正好是我想要的效果，关于BFC的特性可以参考：<a href="https://yaojunblog.cn/2018/12/12/BFC%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88/" target="_blank" rel="noopener">BFC到底是什么</a>，这种方式如果左边不设置宽度<strong>就可以实现左边自动撑开右边自适应布局</strong>。</p><h2 id="5-根据absolute和margin实现左边固定右边自适应布局"><a href="#5-根据absolute和margin实现左边固定右边自适应布局" class="headerlink" title="5. 根据absolute和margin实现左边固定右边自适应布局"></a>5. 根据absolute和margin实现左边固定右边自适应布局</h2><iframe src="https://codesandbox.io/embed/4xp8o28vo9" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe><h3 id="Note-3"><a href="#Note-3" class="headerlink" title="Note"></a>Note</h3><p>这种方式和float+margin方式很像，但是需要注意的是absolute的布局的父元素是非static元素。因此如果要使用这种方式，就需要把父元素设置成非static布局。</p><h2 id="6-仅根据absolute-left实现左边固定右边自适应布局"><a href="#6-仅根据absolute-left实现左边固定右边自适应布局" class="headerlink" title="6. 仅根据absolute+left实现左边固定右边自适应布局"></a>6. 仅根据absolute+left实现左边固定右边自适应布局</h2><iframe src="https://codesandbox.io/embed/2p8n6o0zyp" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe><h3 id="Note-4"><a href="#Note-4" class="headerlink" title="Note"></a>Note</h3><p>通过absolute布局让容器脱离的文档流，之后通过left属性进行偏移。</p><h2 id="7-display-table布局实现左边固定右边自适应布局"><a href="#7-display-table布局实现左边固定右边自适应布局" class="headerlink" title="7. display:table布局实现左边固定右边自适应布局"></a>7. display:table布局实现左边固定右边自适应布局</h2><iframe src="https://codesandbox.io/embed/kpj95xqmr" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe><h3 id="Note-5"><a href="#Note-5" class="headerlink" title="Note"></a>Note</h3><p>通过display:table可以使得元素拥有table的特性，因此可以通过table特性来达到其效果；其实我们也可以通过使用真正的table标签来实现其功能，在这里我就不累述了，有兴趣大家可以自己去实现以下。</p><h2 id="8-flex布局实现左边固定右边自适应布局"><a href="#8-flex布局实现左边固定右边自适应布局" class="headerlink" title="8. flex布局实现左边固定右边自适应布局"></a>8. flex布局实现左边固定右边自适应布局</h2><iframe src="https://codesandbox.io/embed/wo44m0zkol" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe><h3 id="Note-6"><a href="#Note-6" class="headerlink" title="Note"></a>Note</h3><p>flex布局正在改变传统的布局方式，让布局变得更简单。如果你对flex布局还是不很了解，请参考：<a href="https://www.w3cplus.com/css3/understanding-flexbox-everything-you-need-to-know.html" target="_blank" rel="noopener">理解Flexbox：你需要知道的一切</a></p><h3 id="兼容性-1"><a href="#兼容性-1" class="headerlink" title="兼容性"></a>兼容性</h3><img src="/post/915039209/flex.png"><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div class="note default"><p><a href="https://www.cnblogs.com/wangzhenyu666/p/7904522.html" target="_blank" rel="noopener">css实现两栏布局，左侧固定宽，右侧自适应的7中方法</a><br><a href="https://blog.csdn.net/gladys_1111/article/details/77279985" target="_blank" rel="noopener">inline-block布局产生间隙的原因及解决办法（水平、垂直）</a></p></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;闲言&quot;&gt;&lt;a href=&quot;#闲言&quot; class=&quot;headerlink&quot; title=&quot;闲言&quot;&gt;&lt;/a&gt;闲言&lt;/h2&gt;&lt;p&gt;在我们平常的布局中两栏布局是很常见的一种布局方式，并且对于两栏布局的实现方式也是层出不穷；之前忙于工作和happy，没有时间去整理这方面知识
      
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="两栏布局" scheme="http://yoursite.com/tags/%E4%B8%A4%E6%A0%8F%E5%B8%83%E5%B1%80/"/>
    
      <category term="css" scheme="http://yoursite.com/tags/css/"/>
    
  </entry>
  
  <entry>
    <title>vue双向绑定原理笔录</title>
    <link href="http://yoursite.com/post/2399374655.html"/>
    <id>http://yoursite.com/post/2399374655.html</id>
    <published>2019-01-01T12:35:10.000Z</published>
    <updated>2019-01-15T16:50:36.864Z</updated>
    
    <content type="html"><![CDATA[<h2 id="闲言"><a href="#闲言" class="headerlink" title="闲言"></a>闲言</h2><p><script src="https://gist.github.com/xtylovesyj/210e36aec55099b2ff9dcc4b1448e536.js"></script></p><p><script src="https://gist.github.com/xtylovesyj/6f3ab21ccc2421b0dfec94b0b2ce3bbe.js"></script></p><p><script src="https://gist.github.com/xtylovesyj/2b3a69b52b97f7f1176ef1b766dfd3bc.js"></script></p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><div class="note default"><p><a href="https://www.cnblogs.com/libin-1/p/6893712.html" target="_blank" rel="noopener"><font color="red">vue的双向绑定原理及实现</font></a></p></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;闲言&quot;&gt;&lt;a href=&quot;#闲言&quot; class=&quot;headerlink&quot; title=&quot;闲言&quot;&gt;&lt;/a&gt;闲言&lt;/h2&gt;&lt;p&gt;&lt;script src=&quot;https://gist.github.com/xtylovesyj/210e36aec55099b2ff9dcc
      
    
    </summary>
    
      <category term="javascript" scheme="http://yoursite.com/categories/javascript/"/>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
      <category term="双向绑定原理" scheme="http://yoursite.com/tags/%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
</feed>
